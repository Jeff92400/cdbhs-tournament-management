<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>G√©n√©rer Poules - CDBHS</title>
  <link rel="icon" type="image/png" href="images/billiard-icon.png">
  <link rel="stylesheet" href="css/styles.css">
  <style>
    .player-list {
      max-height: 400px;
      overflow-y: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    .player-item {
      display: flex;
      align-items: center;
      padding: 10px 15px;
      border-bottom: 1px solid #eee;
      cursor: pointer;
      transition: background 0.2s;
    }
    .player-item:hover {
      background: #f5f5f5;
    }
    .player-item.selected {
      background: #e3f2fd;
    }
    .player-item.new-player {
      background: #fff3e0;
    }
    .player-item.new-player.selected {
      background: #ffe0b2;
    }
    .player-item input[type="checkbox"] {
      margin-right: 15px;
      transform: scale(1.2);
    }
    .player-rank {
      width: 40px;
      font-weight: bold;
      color: #1F4788;
    }
    .player-name {
      flex: 1;
      font-weight: 500;
    }
    .player-club {
      color: #666;
      font-size: 0.9em;
      margin-left: 10px;
    }
    .player-licence {
      color: #999;
      font-size: 0.85em;
      margin-left: 10px;
    }
    .badge {
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 0.75em;
      margin-left: 10px;
    }
    .badge-new {
      background: #ff9800;
      color: white;
    }
    .badge-forfait {
      background: #dc3545;
      color: white;
    }
    .badge-inscrit {
      background: #28a745;
      color: white;
    }
    .poule-preview {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 15px;
      margin-top: 20px;
    }
    .poule-card {
      border: 2px solid #1F4788;
      border-radius: 8px;
      padding: 15px;
      background: white;
    }
    .poule-card h4 {
      margin: 0 0 10px 0;
      color: #1F4788;
      border-bottom: 1px solid #ddd;
      padding-bottom: 5px;
    }
    .poule-player {
      padding: 5px 0;
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .poule-player-rank {
      width: 25px;
      font-weight: bold;
      color: #666;
    }
    .move-player-btn {
      margin-left: auto;
      padding: 2px 8px;
      font-size: 0.75em;
      background: #6c757d;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      opacity: 0.7;
      transition: opacity 0.2s;
    }
    .move-player-btn:hover {
      opacity: 1;
    }
    .move-dropdown {
      position: absolute;
      background: white;
      border: 1px solid #ddd;
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      z-index: 100;
      min-width: 120px;
    }
    .move-dropdown-item {
      padding: 8px 12px;
      cursor: pointer;
      transition: background 0.2s;
    }
    .move-dropdown-item:hover {
      background: #f5f5f5;
    }
    .poule-card {
      position: relative;
    }
    .step-indicator {
      display: flex;
      justify-content: center;
      margin-bottom: 30px;
    }
    .step {
      display: flex;
      align-items: center;
      color: #999;
    }
    .step.active {
      color: #1F4788;
      font-weight: bold;
    }
    .step.completed {
      color: #28a745;
    }
    .step-number {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: #ddd;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-right: 8px;
      font-weight: bold;
    }
    .step.active .step-number {
      background: #1F4788;
      color: white;
    }
    .step.completed .step-number {
      background: #28a745;
      color: white;
    }
    .step-separator {
      width: 50px;
      height: 2px;
      background: #ddd;
      margin: 0 15px;
    }
    .summary-box {
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 8px;
      padding: 15px;
      margin: 15px 0;
    }
    .summary-row {
      display: flex;
      justify-content: space-between;
      padding: 5px 0;
    }
    .action-buttons {
      display: flex;
      gap: 10px;
      margin-top: 20px;
    }

    /* Upcoming tournament cards */
    .upcoming-tournament-card {
      border: 2px solid #dee2e6;
      border-radius: 12px;
      padding: 15px;
      background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .upcoming-tournament-card:hover {
      border-color: #1F4788;
      box-shadow: 0 4px 12px rgba(31, 71, 136, 0.15);
      transform: translateY(-2px);
    }
    .upcoming-tournament-card .tournament-mode {
      font-size: 0.85em;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 5px;
    }
    .upcoming-tournament-card .tournament-name {
      font-size: 1.1em;
      font-weight: bold;
      color: #1F4788;
      margin-bottom: 10px;
    }
    .upcoming-tournament-card .tournament-details {
      font-size: 0.9em;
      color: #666;
    }
    .upcoming-tournament-card .tournament-details span {
      display: block;
      margin-bottom: 3px;
    }
    .upcoming-tournament-card .tournament-date {
      color: #28a745;
      font-weight: 500;
    }
    .upcoming-tournament-card .tournament-inscrits {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid #eee;
      font-weight: 500;
      color: #17a2b8;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="navbar">
      <h2><img src="images/billiard-icon.png" alt="üé±" style="height: 28px; width: 28px; vertical-align: middle; margin-right: 8px;" onerror="this.style.display='none'; this.nextSibling.style.display='inline';"><span style="display:none;">üé±</span> Comp√©titions √† Jouer</h2>
      <div class="nav-links">
        <a href="dashboard.html">Accueil</a>
        <a href="rankings.html">Classements</a>
        <a href="generate-poules.html" class="active">Comp√©titions</a>
        <a href="emailing.html" class="admin-only">Emailing</a>
        <a href="settings.html" class="admin-only">Param√®tres</a>
        <a href="#" id="logoutBtn" class="nav-logout">D√©connexion</a>
      </div>
    </div>

    <div id="errorMessage" class="error" style="display: none;"></div>
    <div id="successMessage" class="success" style="display: none;"></div>

    <!-- Warning: Update inscriptions -->
    <div class="card" id="inscriptionWarning" style="background: linear-gradient(135deg, #fff3cd 0%, #ffeeba 100%); border-left: 5px solid #ffc107; margin-bottom: 20px;">
      <div style="display: flex; align-items: flex-start; gap: 15px;">
        <div style="font-size: 32px;">‚ö†Ô∏è</div>
        <div style="flex: 1;">
          <h3 style="margin: 0 0 10px 0; color: #856404;">Mise √† jour des inscriptions</h3>
          <p style="margin: 0 0 10px 0; color: #856404;">
            Avant de g√©n√©rer les poules, assurez-vous que les fichiers sont √† jour depuis la base IONOS.
          </p>
          <div id="lastImportInfo" style="margin: 0 0 15px 0; padding: 10px 12px; background: rgba(255,255,255,0.5); border-radius: 4px;">
            <span style="color: #666;">Chargement des informations...</span>
          </div>
          <div style="display: flex; gap: 10px; flex-wrap: wrap;">
            <a href="import-external.html" class="btn" style="background: #ffc107; color: #856404; font-weight: bold;">
              üì§ Mettre √† jour les inscriptions
            </a>
            <button class="btn" id="skipInscriptionUpdate" style="background: #6c757d;">
              Continuer sans mise √† jour ‚Üí
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Upcoming Competitions Section (Tournaments + Finals) -->
    <div class="card" id="upcomingTournamentsCard" style="display: none;">
      <h3>üóìÔ∏è Comp√©titions √† venir</h3>
      <p style="color: #666; margin-bottom: 15px;">
        Cliquez sur un tournoi pour pr√©-remplir automatiquement la s√©lection.
      </p>
      <div id="upcomingTournamentsList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 15px;">
        <!-- Tournaments and Finals will be loaded here -->
      </div>
      <div id="noUpcomingTournaments" style="display: none; text-align: center; padding: 20px; color: #666;">
        <p>Aucune comp√©tition pr√©vue prochainement.</p>
      </div>
    </div>

    <!-- Step Indicator -->
    <div class="step-indicator" id="stepIndicatorContainer" style="display: none;">
      <div class="step active" id="step1Indicator">
        <span class="step-number">1</span>
        <span>S√©lection</span>
      </div>
      <div class="step-separator"></div>
      <div class="step" id="step2Indicator">
        <span class="step-number">2</span>
        <span>Joueurs</span>
      </div>
      <div class="step-separator"></div>
      <div class="step" id="step3Indicator">
        <span class="step-number">3</span>
        <span>Validation</span>
      </div>
      <div class="step-separator"></div>
      <div class="step" id="step4Indicator">
        <span class="step-number">4</span>
        <span>G√©n√©ration</span>
      </div>
    </div>

    <!-- Step 1: Select Tournament -->
    <div class="card" id="step1" style="display: none;">
      <h3>√âtape 1: S√©lectionner le Tournoi</h3>

      <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin-bottom: 20px;">
        <div>
          <label for="categorySelect" style="display: block; margin-bottom: 5px; font-weight: 500;">Cat√©gorie</label>
          <select id="categorySelect" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px;">
            <option value="">-- S√©lectionner --</option>
          </select>
        </div>
        <div>
          <label for="seasonSelect" style="display: block; margin-bottom: 5px; font-weight: 500;">Saison</label>
          <select id="seasonSelect" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px;">
            <option value="">-- S√©lectionner --</option>
          </select>
        </div>
        <div>
          <label for="tournamentSelect" style="display: block; margin-bottom: 5px; font-weight: 500;">Comp√©tition √† pr√©parer</label>
          <select id="tournamentSelect" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px;">
            <option value="">-- S√©lectionner --</option>
            <option value="1">Tournoi 1</option>
            <option value="2">Tournoi 2</option>
            <option value="3">Tournoi 3</option>
            <option value="Finale">üèÜ Finale D√©partementale</option>
          </select>
        </div>
      </div>

      <div id="tournamentInfo" style="display: none; margin-bottom: 20px; padding: 15px; background: #e3f2fd; border-radius: 8px; border-left: 4px solid #1F4788;">
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <div>
            <strong id="tournamentInfoName" style="color: #1F4788; font-size: 1.1em;">-</strong>
            <p style="margin: 5px 0 0 0; color: #666;">
              Date: <strong id="tournamentInfoDate">-</strong> |
              Lieu: <strong id="tournamentInfoLieu">-</strong> |
              Inscrits: <strong id="tournamentInfoInscrits">-</strong>
            </p>
          </div>
        </div>
      </div>

      <button class="btn" id="loadPlayersBtn" disabled>Charger les joueurs</button>
    </div>

    <!-- Step 2: Select Players -->
    <div class="card" id="step2" style="display: none;">
      <h3>√âtape 2: S√©lectionner les Joueurs</h3>

      <div class="summary-box">
        <div class="summary-row">
          <span>Joueurs s√©lectionn√©s:</span>
          <strong id="selectedCount">0</strong>
        </div>
        <div class="summary-row">
          <span>Configuration des poules:</span>
          <strong id="pouleConfig">-</strong>
        </div>
        <div class="summary-row">
          <span>Tables n√©cessaires:</span>
          <strong id="tablesNeeded">-</strong>
        </div>
      </div>

      <div style="margin-bottom: 15px; display: flex; gap: 10px;">
        <button class="btn" id="selectAllBtn">Tout s√©lectionner</button>
        <button class="btn" id="deselectAllBtn" style="background: #6c757d;">Tout d√©s√©lectionner</button>
        <button class="btn" id="selectRegisteredBtn" style="background: #17a2b8;">S√©lectionner les inscrits</button>
      </div>

      <h4 id="rankedPlayersTitle">Joueurs class√©s (du classement actuel)</h4>
      <div class="player-list" id="rankedPlayersList">
        <p style="padding: 20px; color: #666; text-align: center;">Chargement...</p>
      </div>

      <h4 style="margin-top: 20px;" id="newPlayersTitle">Nouveaux joueurs (inscrits non class√©s)</h4>
      <div class="player-list" id="newPlayersList">
        <p style="padding: 20px; color: #666; text-align: center;">Aucun nouveau joueur</p>
      </div>

      <h4 style="margin-top: 20px;">Ajout last minute</h4>
      <div style="background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 15px;">
        <p style="color: #666; font-size: 0.9em; margin-bottom: 10px;">Ajouter un joueur qui n'est pas inscrit dans le syst√®me externe</p>
        <div style="display: flex; gap: 10px; align-items: center;">
          <input type="text" id="lastMinuteSearch" placeholder="Rechercher par nom ou licence..."
                 style="flex: 1; padding: 10px; border: 1px solid #ddd; border-radius: 4px;">
          <button class="btn" id="addLastMinuteBtn" style="background: #dc3545;" disabled>Ajouter</button>
        </div>
        <div id="lastMinuteResults" style="display: none; max-height: 200px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; margin-top: 10px; background: white;"></div>
        <div class="player-list" id="lastMinutePlayersList" style="margin-top: 10px; max-height: 150px;"></div>
      </div>

      <div class="action-buttons">
        <button class="btn" id="backToStep1Btn" style="background: #6c757d;">Retour</button>
        <button class="btn" id="validatePlayersBtn" disabled>Valider la liste</button>
      </div>
    </div>

    <!-- Step 3: Validate & Preview -->
    <div class="card" id="step3" style="display: none;">
      <h3>√âtape 3: Validation et Aper√ßu</h3>

      <div class="summary-box">
        <div class="summary-row">
          <span>Cat√©gorie:</span>
          <strong id="summaryCategory">-</strong>
        </div>
        <div class="summary-row">
          <span>Tournoi:</span>
          <strong id="summaryTournament">-</strong>
        </div>
        <div class="summary-row">
          <span>Date:</span>
          <strong id="summaryDate">-</strong>
        </div>
        <div class="summary-row">
          <span>Lieu:</span>
          <strong id="summaryLieu">-</strong>
        </div>
        <div class="summary-row">
          <span>Nombre de joueurs:</span>
          <strong id="summaryPlayers">-</strong>
        </div>
        <div class="summary-row">
          <span>Configuration:</span>
          <strong id="summaryConfig">-</strong>
        </div>
        <div class="summary-row">
          <span>Tables n√©cessaires:</span>
          <strong id="summaryTables">-</strong>
        </div>
      </div>

      <!-- Game Parameters Section -->
      <div id="gameParamsSection" style="display: none; margin: 20px 0; padding: 15px; background: #e7f3ff; border-left: 4px solid #1F4788; border-radius: 4px;">
        <h4 style="margin: 0 0 15px 0; color: #1F4788;">Param√®tres de l'√©preuve</h4>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
          <div>
            <label style="display: block; font-weight: 500; margin-bottom: 5px;">Distance :</label>
            <select id="distanceSelect" style="width: 100%; padding: 10px; border: 1px solid #1F4788; border-radius: 4px; font-size: 14px;">
              <option value="normale">Distance Normale</option>
            </select>
          </div>
          <div>
            <span style="display: block; font-weight: 500; margin-bottom: 5px;">Coin :</span>
            <span id="gameParamCoin" style="display: inline-block; padding: 8px 15px; border-radius: 4px; background: #17a2b8; color: white; font-weight: bold;">-</span>
          </div>
          <div>
            <span style="display: block; font-weight: 500; margin-bottom: 5px;">Reprises max :</span>
            <span id="gameParamReprises" style="font-size: 18px; font-weight: bold; color: #1F4788;">-</span>
          </div>
        </div>
        <p id="gameParamMoyenne" style="margin: 15px 0 0 0; padding: 10px; background: #fff; border-radius: 4px; font-size: 13px; color: #666;">
          -
        </p>
      </div>

      <h4 id="poulePreviewTitle">Aper√ßu des Poules (Distribution Serpentine)</h4>
      <div class="poule-preview" id="poulePreview">
        <!-- Poules will be rendered here -->
      </div>

      <h4 style="margin-top: 30px;">Lieu et Horaire de la Comp√©tition</h4>
      <div class="summary-box">
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
          <div>
            <label style="display: block; margin-bottom: 5px; font-weight: 500;">Lieu principal</label>
            <select id="locationSelect1" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px;">
              <option value="">-- S√©lectionner un club --</option>
            </select>
          </div>
          <div>
            <label style="display: block; margin-bottom: 5px; font-weight: 500;">Heure de d√©but</label>
            <select id="startTime1" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px;">
              <option value="">-- S√©lectionner --</option>
              <option value="08:00">08:00</option>
              <option value="08:30">08:30</option>
              <option value="09:00">09:00</option>
              <option value="09:30">09:30</option>
              <option value="10:00">10:00</option>
              <option value="10:30">10:30</option>
              <option value="11:00">11:00</option>
              <option value="11:30">11:30</option>
              <option value="12:00">12:00</option>
              <option value="12:30">12:30</option>
              <option value="13:00">13:00</option>
              <option value="13:30" selected>13:30</option>
              <option value="14:00">14:00</option>
              <option value="14:30">14:30</option>
              <option value="15:00">15:00</option>
              <option value="15:30">15:30</option>
              <option value="16:00">16:00</option>
              <option value="16:30">16:30</option>
              <option value="17:00">17:00</option>
              <option value="17:30">17:30</option>
              <option value="18:00">18:00</option>
            </select>
          </div>
        </div>

        <div id="location2Container" style="display: none; margin-top: 15px; padding-top: 15px; border-top: 1px dashed #ddd;">
          <div style="display: grid; grid-template-columns: 1fr 1fr auto; gap: 20px; align-items: end;">
            <div>
              <label style="display: block; margin-bottom: 5px; font-weight: 500;">Lieu secondaire (split)</label>
              <select id="locationSelect2" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px;">
                <option value="">-- S√©lectionner un club --</option>
              </select>
            </div>
            <div>
              <label style="display: block; margin-bottom: 5px; font-weight: 500;">Heure de d√©but</label>
              <select id="startTime2" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px;">
                <option value="">-- S√©lectionner --</option>
                <option value="08:00">08:00</option>
                <option value="08:30">08:30</option>
                <option value="09:00">09:00</option>
                <option value="09:30">09:30</option>
                <option value="10:00">10:00</option>
                <option value="10:30">10:30</option>
                <option value="11:00">11:00</option>
                <option value="11:30">11:30</option>
                <option value="12:00">12:00</option>
                <option value="12:30">12:30</option>
                <option value="13:00">13:00</option>
                <option value="13:30">13:30</option>
                <option value="14:00" selected>14:00</option>
                <option value="14:30">14:30</option>
                <option value="15:00">15:00</option>
                <option value="15:30">15:30</option>
                <option value="16:00">16:00</option>
                <option value="16:30">16:30</option>
                <option value="17:00">17:00</option>
                <option value="17:30">17:30</option>
                <option value="18:00">18:00</option>
              </select>
            </div>
            <button class="btn" id="removeLocation2Btn" style="background: #dc3545; padding: 10px 15px;">Retirer</button>
          </div>
        </div>

        <div style="margin-top: 15px;">
          <button class="btn" id="addLocation2Btn" style="background: #17a2b8;">+ Ajouter un second lieu (split)</button>
        </div>
      </div>

      <div class="action-buttons">
        <button class="btn" id="backToStep2Btn" style="background: #6c757d;">Modifier la liste</button>
        <button class="btn btn-success" id="generateExcelBtn" style="background: #28a745;">G√©n√©rer le fichier Excel</button>
        <button class="btn" id="generateSummaryPdfBtn" style="background: #dc3545; color: white;">G√©n√©rer PDF R√©capitulatif</button>
      </div>
    </div>

    <!-- Step 4: Download -->
    <div class="card" id="step4" style="display: none;">
      <h3>√âtape 4: T√©l√©chargement</h3>
      <div style="text-align: center; padding: 40px;">
        <div style="font-size: 48px; margin-bottom: 20px;">‚úÖ</div>
        <h4>Fichier g√©n√©r√© avec succ√®s !</h4>
        <p style="color: #666; margin-bottom: 20px;">Le fichier Excel a √©t√© t√©l√©charg√© automatiquement.</p>

        <!-- Email convocations section -->
        <div id="emailSection" style="margin: 30px 0; padding: 20px; background: #f8f9fa; border-radius: 8px; border: 1px solid #dee2e6;">
          <h4 style="margin: 0 0 15px 0; color: #1F4788;">üìß Envoyer les convocations par email</h4>
          <p style="color: #666; margin-bottom: 15px;">
            Envoyer une convocation personnalis√©e √† chaque joueur avec le d√©tail de sa poule.
          </p>
          <div id="emailStats" style="margin-bottom: 15px; padding: 10px; background: white; border-radius: 4px;">
            <span id="emailableCount">-</span> joueurs avec email valide sur <span id="totalPlayersCount">-</span>
          </div>

          <!-- Player selection list -->
          <div id="playerSelectionSection" style="margin-bottom: 15px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
              <label style="font-weight: bold; color: #333;">S√©lectionner les joueurs √† convoquer :</label>
              <div>
                <button type="button" id="emailSelectAllBtn" class="btn" style="background: #28a745; padding: 5px 10px; font-size: 12px; margin-right: 5px;">Tout cocher</button>
                <button type="button" id="emailDeselectAllBtn" class="btn" style="background: #dc3545; padding: 5px 10px; font-size: 12px;">Tout d√©cocher</button>
              </div>
            </div>
            <div id="playerCheckboxList" style="max-height: 300px; overflow-y: auto; background: white; border: 1px solid #ddd; border-radius: 4px; padding: 10px;">
              <!-- Player checkboxes will be inserted here -->
            </div>
            <div id="selectedCount" style="margin-top: 10px; font-size: 14px; color: #666;">
              <strong><span id="checkedCount">0</span></strong> joueur(s) s√©lectionn√©(s) pour l'envoi
              <br><span style="color: #17a2b8;">üìã R√©capitulatif envoy√© √† : <strong id="summaryEmailDisplay">cdbhs92@gmail.com</strong></span>
            </div>
          </div>

          <!-- Special note field -->
          <div style="margin-bottom: 15px;">
            <label style="display: block; font-weight: bold; color: #333; margin-bottom: 8px;">
              Note particuli√®re √† inscrire sur l'email d'envoi :
            </label>
            <textarea id="specialNoteField"
                      placeholder="Exemple: Attention, le tournoi d√©butera exceptionnellement √† 13H00 ce samedi..."
                      style="width: 100%; min-height: 80px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-family: inherit; font-size: 14px; resize: vertical;"></textarea>
            <p style="margin: 5px 0 0 0; font-size: 12px; color: #666;">
              Cette note appara√Ætra en √©vidence en haut de l'email, avant le message de convocation.
            </p>
          </div>

          <button class="btn" id="sendConvocationsBtn" style="background: #17a2b8;">
            ‚úâÔ∏è Envoyer les convocations
          </button>
          <div id="emailProgress" style="display: none; margin-top: 15px;">
            <div style="background: #e9ecef; border-radius: 4px; overflow: hidden;">
              <div id="emailProgressBar" style="height: 8px; background: #17a2b8; width: 0%; transition: width 0.3s;"></div>
            </div>
            <p id="emailProgressText" style="color: #666; margin-top: 10px;"></p>
          </div>
          <div id="emailResults" style="display: none; margin-top: 15px; text-align: left;"></div>
        </div>

        <div class="action-buttons" style="justify-content: center;">
          <button class="btn" id="backToStep3Btn" style="background: #6c757d;">Retour √† l'aper√ßu</button>
          <button class="btn" id="newGenerationBtn">Nouvelle g√©n√©ration</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    const API_URL = '/api';

    // Check authentication
    const token = localStorage.getItem('token');
    if (!token) {
      window.location.href = 'login.html';
    }

    // Check user role and show/hide admin elements
    const userRole = localStorage.getItem('userRole');
    if (userRole === 'admin') {
      document.querySelectorAll('.admin-only').forEach(el => el.style.display = '');
    } else {
      document.querySelectorAll('.admin-only').forEach(el => el.style.display = 'none');
    }

    // Load summary email setting for display
    (async function loadSummaryEmailDisplay() {
      try {
        const response = await fetch(`${API_URL}/settings/app/summary_email`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        if (response.ok) {
          const data = await response.json();
          const email = data.value || 'cdbhs92@gmail.com';
          document.getElementById('summaryEmailDisplay').textContent = email;
        }
      } catch (error) {
        console.error('Error loading summary email:', error);
      }
    })();

    // Logout
    document.getElementById('logoutBtn').addEventListener('click', (e) => {
      e.preventDefault();
      localStorage.removeItem('token');
      localStorage.removeItem('userRole');
      localStorage.removeItem('username');
      window.location.href = 'login.html';
    });

    // Skip inscription update warning
    document.getElementById('skipInscriptionUpdate').addEventListener('click', () => {
      document.getElementById('inscriptionWarning').style.display = 'none';
      document.getElementById('stepIndicatorContainer').style.display = 'flex';
      document.getElementById('step1').style.display = 'block';
      // Show and load upcoming tournaments
      document.getElementById('upcomingTournamentsCard').style.display = 'block';
      loadUpcomingTournaments();
    });

    // Format import age with color coding
    function formatImportAge(importDate) {
      if (!importDate) {
        return { text: 'Jamais import√©', color: '#dc3545', isOld: true };
      }

      const lastDate = new Date(importDate);
      const now = new Date();
      const diffMs = now - lastDate;
      const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
      const diffHours = Math.floor(diffMs / (1000 * 60 * 60));

      let ageText = '';
      let ageColor = '#28a745'; // green
      let isOld = false;

      if (diffDays > 7) {
        ageText = `il y a ${diffDays} jours`;
        ageColor = '#dc3545'; // red - very old
        isOld = true;
      } else if (diffDays > 2) {
        ageText = `il y a ${diffDays} jours`;
        ageColor = '#fd7e14'; // orange - old
        isOld = true;
      } else if (diffDays > 0) {
        ageText = `il y a ${diffDays} jour${diffDays > 1 ? 's' : ''}`;
        ageColor = '#ffc107'; // yellow - recent
      } else if (diffHours > 0) {
        ageText = `il y a ${diffHours} heure${diffHours > 1 ? 's' : ''}`;
        ageColor = '#28a745'; // green - very recent
      } else {
        ageText = "√† l'instant";
        ageColor = '#28a745'; // green
      }

      return { text: ageText, color: ageColor, isOld };
    }

    // Get season for a given date (Sept-Aug cycle)
    function getSeasonForDate(date) {
      const year = date.getFullYear();
      const month = date.getMonth(); // 0-11
      if (month >= 8) {
        return `${year}-${year + 1}`;
      } else {
        return `${year - 1}-${year}`;
      }
    }

    // Load and display last import dates for all file types
    async function loadLastImportDate() {
      try {
        const response = await fetch(`${API_URL}/inscriptions/last-import`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });

        const infoElement = document.getElementById('lastImportInfo');

        if (response.ok) {
          const data = await response.json();

          // Get current season
          const currentSeason = getSeasonForDate(new Date());

          // Fetch tournois and inscriptions to calculate season-specific counts
          let seasonTournoiCount = 0;
          let seasonInscriptionCount = 0;
          let tournoiMap = {};

          try {
            const tournoiRes = await fetch(`${API_URL}/inscriptions/tournoi`, {
              headers: { 'Authorization': `Bearer ${token}` }
            });
            if (tournoiRes.ok) {
              const tournois = await tournoiRes.json();
              tournois.forEach(t => { tournoiMap[t.tournoi_id] = t; });
              seasonTournoiCount = tournois.filter(t => {
                if (!t.debut) return false;
                return getSeasonForDate(new Date(t.debut)) === currentSeason;
              }).length;
            }

            const inscRes = await fetch(`${API_URL}/inscriptions`, {
              headers: { 'Authorization': `Bearer ${token}` }
            });
            if (inscRes.ok) {
              const inscriptions = await inscRes.json();
              seasonInscriptionCount = inscriptions.filter(i => {
                const tournoi = tournoiMap[i.tournoi_id];
                if (!tournoi || !tournoi.debut) return false;
                return getSeasonForDate(new Date(tournoi.debut)) === currentSeason;
              }).length;
            }
          } catch (e) {
            console.error('Error fetching season counts:', e);
          }

          const fileTypes = [
            { key: 'inscriptions', label: 'Inscriptions', icon: 'üìù', seasonCount: seasonInscriptionCount },
            { key: 'tournois', label: 'Tournois', icon: 'üèÜ', seasonCount: seasonTournoiCount },
            { key: 'joueurs', label: 'Joueurs', icon: 'üë•', seasonCount: null }
          ];

          let html = `<div style="display: grid; gap: 8px;">`;
          html += `<div style="font-size: 11px; color: #856404; margin-bottom: 5px;">Saison ${currentSeason}</div>`;

          fileTypes.forEach(ft => {
            const info = data[ft.key];
            const age = formatImportAge(info?.importDate);
            const countDisplay = ft.seasonCount !== null ? ft.seasonCount : (info?.recordCount || 0);

            html += `
              <div style="display: flex; align-items: center; gap: 10px;">
                <span style="width: 24px;">${ft.icon}</span>
                <span style="min-width: 100px; color: #856404; font-weight: 500;">${ft.label}:</span>
                <span style="color: ${age.color}; font-weight: ${age.isOld ? 'bold' : 'normal'};">
                  ${age.text}
                  <span style="color: #666; font-weight: normal;"> (${countDisplay} enregistrements)</span>
                </span>
              </div>
            `;
          });

          html += '</div>';
          infoElement.innerHTML = html;
        } else {
          infoElement.innerHTML = `<span style="color: #666;">Impossible de charger les informations</span>`;
        }
      } catch (error) {
        console.error('Error loading last import date:', error);
        document.getElementById('lastImportInfo').innerHTML = `<span style="color: #666;">Erreur de chargement</span>`;
      }
    }

    // Load last import date on page load
    loadLastImportDate();

    // State
    let categories = [];
    let rankedPlayers = [];
    let newPlayers = [];
    let lastMinutePlayers = [];
    let allSystemPlayers = [];
    let selectedPlayers = [];
    let currentCategory = null;
    let currentSeason = null;
    let currentTournament = null;
    let externalTournois = [];
    let matchingTournoi = null;
    let selectedLastMinutePlayer = null;
    let clubs = [];
    let currentGameParams = null;
    let isFinale = false;

    // Poule configuration based on number of players
    const POULE_CONFIG = {
      3: { poules: [3], tables: 1 },
      4: { poules: [4], tables: 2 },
      5: { poules: [5], tables: 2 },
      6: { poules: [3, 3], tables: 2 },
      7: { poules: [3, 4], tables: 3 },
      8: { poules: [3, 5], tables: 3 },
      9: { poules: [3, 3, 3], tables: 3 },
      10: { poules: [3, 3, 4], tables: 4 },
      11: { poules: [3, 3, 5], tables: 4 },
      12: { poules: [3, 3, 3, 3], tables: 4 },
      13: { poules: [3, 3, 3, 4], tables: 5 },
      14: { poules: [3, 3, 3, 5], tables: 5 },
      15: { poules: [3, 3, 3, 3, 3], tables: 5 },
      16: { poules: [3, 3, 3, 3, 4], tables: 6 },
      17: { poules: [3, 3, 3, 3, 5], tables: 6 },
      18: { poules: [3, 3, 3, 3, 3, 3], tables: 6 },
      19: { poules: [3, 3, 3, 3, 3, 4], tables: 7 },
      20: { poules: [3, 3, 3, 3, 3, 5], tables: 7 }
    };

    // Get poule configuration for a given number of players
    function getPouleConfig(numPlayers) {
      if (numPlayers < 3) {
        return { poules: [], tables: 0, description: 'Pas assez de joueurs' };
      }
      if (numPlayers > 20) {
        // Extend pattern for more than 20 players
        const base = Math.floor(numPlayers / 3);
        const remainder = numPlayers % 3;
        const poules = Array(base).fill(3);
        if (remainder === 1) {
          poules[poules.length - 1] = 4;
        } else if (remainder === 2) {
          poules[poules.length - 1] = 5;
        }
        return {
          poules,
          tables: poules.length + 1,
          description: formatPouleDescription(poules)
        };
      }
      const config = POULE_CONFIG[numPlayers];
      return { ...config, description: formatPouleDescription(config.poules) };
    }

    // Format poule description: "5 poules de 3 et 1 poule de 4 (6 poules)"
    function formatPouleDescription(poules) {
      if (poules.length === 0) return '-';
      if (poules.length === 1) return `1 poule de ${poules[0]}`;

      // Count poules by size
      const counts = {};
      poules.forEach(size => {
        counts[size] = (counts[size] || 0) + 1;
      });

      // Build description parts
      const parts = [];
      const sizes = Object.keys(counts).sort((a, b) => a - b);
      sizes.forEach(size => {
        const count = counts[size];
        parts.push(`${count} poule${count > 1 ? 's' : ''} de ${size}`);
      });

      return `${parts.join(' et ')} (${poules.length} poules)`;
    }

    // Serpentine distribution
    function distributeSerpentine(players, pouleSizes) {
      const numPoules = pouleSizes.length;
      const poules = pouleSizes.map((size, i) => ({
        number: i + 1,
        size,
        players: []
      }));

      let playerIndex = 0;
      let round = 0;

      while (playerIndex < players.length) {
        const isLeftToRight = round % 2 === 0;

        for (let i = 0; i < numPoules && playerIndex < players.length; i++) {
          const pouleIndex = isLeftToRight ? i : (numPoules - 1 - i);
          const poule = poules[pouleIndex];

          if (poule.players.length < poule.size) {
            poules[pouleIndex].players.push({
              ...players[playerIndex],
              originalRank: playerIndex + 1
            });
            playerIndex++;
          }
        }
        round++;
      }

      return poules;
    }

    // Load categories
    async function loadCategories() {
      try {
        const response = await fetch(`${API_URL}/tournaments`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        if (response.ok) {
          const tournaments = await response.json();

          // Extract unique categories
          const categoryMap = new Map();
          tournaments.forEach(t => {
            const key = `${t.game_type}-${t.level}`;
            if (!categoryMap.has(key)) {
              categoryMap.set(key, {
                id: t.category_id,
                game_type: t.game_type,
                level: t.level,
                display_name: t.display_name
              });
            }
          });

          categories = Array.from(categoryMap.values());

          const select = document.getElementById('categorySelect');
          select.innerHTML = '<option value="">-- S√©lectionner --</option>';
          categories.forEach(cat => {
            select.innerHTML += `<option value="${cat.id}">${cat.display_name}</option>`;
          });

          // Extract unique seasons
          const seasons = [...new Set(tournaments.map(t => t.season))].sort().reverse();
          const seasonSelect = document.getElementById('seasonSelect');
          seasonSelect.innerHTML = '<option value="">-- S√©lectionner --</option>';
          seasons.forEach(season => {
            seasonSelect.innerHTML += `<option value="${season}">${season}</option>`;
          });

          // Pre-select current season if available
          if (seasons.length > 0) {
            seasonSelect.value = seasons[0];
            currentSeason = seasons[0];
          }
        }
      } catch (error) {
        console.error('Error loading categories:', error);
      }
    }

    loadCategories();

    // Load upcoming competitions (tournaments + finals)
    async function loadUpcomingTournaments() {
      const container = document.getElementById('upcomingTournamentsList');
      const noTournamentsDiv = document.getElementById('noUpcomingTournaments');
      const card = document.getElementById('upcomingTournamentsCard');

      // Show loading state
      container.innerHTML = '<p style="text-align: center; color: #666;">Chargement des comp√©titions...</p>';
      container.style.display = 'block';
      noTournamentsDiv.style.display = 'none';

      try {
        // Fetch both tournaments and finals
        const [tournamentsRes, finalesRes] = await Promise.all([
          fetch(`${API_URL}/inscriptions/tournoi/upcoming`, {
            headers: { 'Authorization': `Bearer ${token}` }
          }),
          fetch(`${API_URL}/inscriptions/finales/upcoming`, {
            headers: { 'Authorization': `Bearer ${token}` }
          }).catch(() => ({ ok: false })) // Handle if endpoint doesn't exist yet
        ]);

        let allCompetitions = [];

        if (tournamentsRes.ok) {
          const tournaments = await tournamentsRes.json();
          tournaments.forEach(t => {
            t.isFinale = false;
          });
          allCompetitions = allCompetitions.concat(tournaments);
        }

        if (finalesRes.ok) {
          const finales = await finalesRes.json();
          finales.forEach(f => {
            f.isFinale = true;
          });
          allCompetitions = allCompetitions.concat(finales);
        }

        // Sort by date
        allCompetitions.sort((a, b) => {
          const dateA = a.debut ? new Date(a.debut) : new Date('9999-12-31');
          const dateB = b.debut ? new Date(b.debut) : new Date('9999-12-31');
          return dateA - dateB;
        });

        if (allCompetitions.length === 0) {
          container.style.display = 'none';
          noTournamentsDiv.style.display = 'block';
        } else {
          container.style.display = 'grid';
          noTournamentsDiv.style.display = 'none';

          container.innerHTML = allCompetitions.map(t => {
            const dateStr = t.debut
              ? new Date(t.debut).toLocaleDateString('fr-FR', { weekday: 'long', day: 'numeric', month: 'long' })
              : 'Date non d√©finie';

            // Extract tournament number from name (e.g., "TOURNOI 2" -> "2") or "Finale" for finals
            const tournamentMatch = t.nom.match(/TOURNOI\s*(\d+)/i);
            const tournamentNum = tournamentMatch ? tournamentMatch[1] : (t.isFinale ? 'Finale' : '');

            const cardStyle = t.isFinale
              ? 'border: 2px solid #ffc107; background: linear-gradient(135deg, #fffde7 0%, #fff8e1 100%);'
              : '';
            const badgeHtml = t.isFinale
              ? '<span style="background: #ffc107; color: #333; padding: 2px 8px; border-radius: 10px; font-size: 10px; font-weight: bold; margin-left: 8px;">üèÜ FINALE</span>'
              : '';

            return `
              <div class="upcoming-tournament-card"
                   style="${cardStyle}"
                   data-mode="${t.mode}"
                   data-categorie="${t.categorie}"
                   data-tournament-num="${tournamentNum}"
                   data-tournoi-id="${t.tournoi_id}"
                   data-lieu="${t.lieu || ''}"
                   data-date="${t.debut || ''}"
                   data-is-finale="${t.isFinale}"
                   data-finalist-count="${t.finalist_count || 0}"
                   data-inscribed-finalist-count="${t.inscribed_finalist_count || 0}">
                <div class="tournament-mode">${t.mode} - ${t.categorie}${badgeHtml}</div>
                <div class="tournament-name">${t.isFinale ? 'Finale D√©partementale' : t.nom}</div>
                <div class="tournament-details">
                  <span class="tournament-date">üìÖ ${dateStr}</span>
                  <span>üìç ${t.lieu || 'Lieu non d√©fini'}</span>
                </div>
                <div class="tournament-inscrits">
                  üë• ${t.isFinale ? `${t.inscribed_finalist_count || 0}/${t.finalist_count || 0} inscrits` : `${t.inscrit_count || 0} inscrit(s)`}
                </div>
              </div>
            `;
          }).join('');

          // Add click handlers
          container.querySelectorAll('.upcoming-tournament-card').forEach(card => {
            card.addEventListener('click', () => selectUpcomingTournament(card));
          });
        }

        card.style.display = 'block';
      } catch (error) {
        console.error('Error loading upcoming competitions:', error);
      }
    }

    // Handle click on upcoming tournament card
    async function selectUpcomingTournament(card) {
      const mode = card.dataset.mode;
      const categorie = card.dataset.categorie;
      const tournamentNum = card.dataset.tournamentNum;
      const tournoiId = card.dataset.tournoiId;
      const lieu = card.dataset.lieu;
      const date = card.dataset.date;
      isFinale = card.dataset.isFinale === 'true';

      // Find matching category using mode_mapping logic
      // We need to match the IONOS mode to our internal game_type
      const modeNormalized = mode.toUpperCase().replace(/\s+/g, '');

      // Mapping from IONOS modes to internal game_types
      const modeToGameType = {
        'LIBRE': 'LIBRE',
        '3BANDES': '3BANDES',
        '3 BANDES': '3BANDES',
        'BANDE': 'BANDE',
        '1BANDE': 'BANDE',
        '1 BANDE': 'BANDE',
        'CADRE': 'CADRE'
      };

      // Mapping from IONOS levels to internal levels
      const levelMapping = {
        'N1': 'NATIONALE 1',
        'N2': 'NATIONALE 2',
        'N3': 'NATIONALE 3',
        'R1': 'REGIONALE 1',
        'R2': 'REGIONALE 2',
        'R3': 'REGIONALE 3',
        'D1': 'DEPARTEMENTALE 1',
        'D2': 'DEPARTEMENTALE 2',
        'D3': 'DEPARTEMENTALE 3'
      };

      const gameType = modeToGameType[mode.toUpperCase()] || modeToGameType[modeNormalized] || mode.toUpperCase();
      const normalizedLevel = levelMapping[categorie.toUpperCase()] || categorie.toUpperCase();

      // Find matching category (use startsWith for flexible matching with suffixes like "GC")
      const matchingCategory = categories.find(c =>
        c.game_type.toUpperCase() === gameType &&
        (c.level.toUpperCase() === normalizedLevel ||
         c.level.toUpperCase() === categorie.toUpperCase() ||
         c.level.toUpperCase().startsWith(normalizedLevel) ||
         c.level.toUpperCase().startsWith(categorie.toUpperCase()))
      );

      if (matchingCategory) {
        // Set dropdowns
        document.getElementById('categorySelect').value = matchingCategory.id;
        // For finals, set tournament to "Finale", otherwise use tournament number
        document.getElementById('tournamentSelect').value = isFinale ? 'Finale' : tournamentNum;

        // Store the selected tournament info for later use (including finalist counts from card data)
        window.selectedUpcomingTournament = {
          tournoiId,
          lieu,
          date,
          mode,
          categorie,
          tournamentNum: isFinale ? 'Finale' : tournamentNum,
          isFinale,
          finalist_count: parseInt(card.dataset.finalistCount) || 0,
          inscribed_finalist_count: parseInt(card.dataset.inscribedFinalistCount) || 0
        };

        // Trigger change event to load tournament info
        document.getElementById('categorySelect').dispatchEvent(new Event('change'));

        // Enable load button
        document.getElementById('loadPlayersBtn').disabled = false;

        // Scroll to step 1
        document.getElementById('step1').scrollIntoView({ behavior: 'smooth', block: 'start' });
      } else {
        alert(`Impossible de trouver la cat√©gorie correspondante pour ${mode} - ${categorie}`);
      }
    }

    // Also load upcoming tournaments when coming from import-external page
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('skipWarning') === 'true') {
      document.getElementById('inscriptionWarning').style.display = 'none';
      document.getElementById('stepIndicatorContainer').style.display = 'flex';
      document.getElementById('step1').style.display = 'block';
      document.getElementById('upcomingTournamentsCard').style.display = 'block';
      loadUpcomingTournaments();
    }

    // Pending location to preselect (stored when preselectLocation is called before clubs load)
    let pendingLocationToPreselect = null;

    // Load clubs for location selection
    async function loadClubs() {
      try {
        const response = await fetch(`${API_URL}/clubs`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        if (response.ok) {
          clubs = await response.json();
          populateLocationDropdowns();
          // Apply pending preselection if any
          if (pendingLocationToPreselect) {
            preselectLocation(pendingLocationToPreselect);
            pendingLocationToPreselect = null;
          }
        }
      } catch (error) {
        console.error('Error loading clubs:', error);
      }
    }

    function populateLocationDropdowns() {
      const select1 = document.getElementById('locationSelect1');
      const select2 = document.getElementById('locationSelect2');

      const options = '<option value="">-- S√©lectionner un club --</option>' +
        clubs.map(c => {
          const fullAddress = [c.street, c.zip_code, c.city].filter(Boolean).join(' ');
          return `<option value="${c.id}"
            data-name="${c.name}"
            data-street="${c.street || ''}"
            data-city="${c.city || ''}"
            data-zipcode="${c.zip_code || ''}"
            data-phone="${c.phone || ''}"
            data-email="${c.email || ''}"
            data-address="${fullAddress}">${c.name}</option>`;
        }).join('');

      select1.innerHTML = options;
      select2.innerHTML = options;
    }

    function preselectLocation(locationName) {
      console.log('[preselectLocation] Called with:', locationName, 'clubs loaded:', clubs.length);
      if (!locationName) return;

      // If clubs not loaded yet, store for later
      if (clubs.length === 0) {
        console.log('[preselectLocation] Clubs not loaded, storing for later');
        pendingLocationToPreselect = locationName;
        return;
      }

      const select1 = document.getElementById('locationSelect1');
      const locationLower = locationName.toLowerCase().trim();

      // Try to find matching club by name or city
      for (const club of clubs) {
        const clubNameLower = club.name.toLowerCase();
        const clubCityLower = (club.city || '').toLowerCase();

        // Check name match
        if (clubNameLower.includes(locationLower) || locationLower.includes(clubNameLower)) {
          console.log('[preselectLocation] Found match by name:', club.name, '-> id:', club.id);
          select1.value = club.id;
          // Update poule labels to reflect the new selection
          updatePouleLocationLabels();
          return;
        }

        // Check city match
        if (clubCityLower === locationLower || clubCityLower.includes(locationLower) || locationLower.includes(clubCityLower)) {
          console.log('[preselectLocation] Found match by city:', club.name, 'city:', club.city, '-> id:', club.id);
          select1.value = club.id;
          // Update poule labels to reflect the new selection
          updatePouleLocationLabels();
          return;
        }
      }
      console.log('[preselectLocation] No match found for:', locationName, 'Available clubs:', clubs.map(c => ({ name: c.name, city: c.city })));
    }

    loadClubs();

    // Location add/remove handlers
    document.getElementById('addLocation2Btn').addEventListener('click', () => {
      document.getElementById('location2Container').style.display = 'block';
      document.getElementById('addLocation2Btn').style.display = 'none';
      updatePouleLocationLabels();
    });

    document.getElementById('removeLocation2Btn').addEventListener('click', () => {
      document.getElementById('location2Container').style.display = 'none';
      document.getElementById('addLocation2Btn').style.display = 'inline-block';
      document.getElementById('locationSelect2').value = '';
      // Reset all poules to location 1
      document.querySelectorAll('.poule-location').forEach(select => select.value = '1');
      updatePouleLocationLabels();
    });

    // Update poule labels when location dropdowns change
    document.getElementById('locationSelect1').addEventListener('change', () => {
      updatePouleLocationLabels();
      // Update summary Lieu when main location changes
      const select = document.getElementById('locationSelect1');
      const selectedOption = select.options[select.selectedIndex];
      if (select.value && selectedOption) {
        document.getElementById('summaryLieu').textContent = selectedOption.dataset.name || selectedOption.text;
      }
    });
    document.getElementById('locationSelect2').addEventListener('change', updatePouleLocationLabels);

    // Update load button state and load tournament info
    function updateLoadButtonState() {
      const categoryId = document.getElementById('categorySelect').value;
      const season = document.getElementById('seasonSelect').value;
      const tournament = document.getElementById('tournamentSelect').value;

      document.getElementById('loadPlayersBtn').disabled = !categoryId || !season || !tournament;

      // Load tournament info if all fields are selected
      if (categoryId && tournament) {
        loadTournamentInfo(categoryId, tournament);
      } else {
        document.getElementById('tournamentInfo').style.display = 'none';
        matchingTournoi = null;
      }
    }

    // Load external tournament info
    async function loadTournamentInfo(categoryId, tournamentNum) {
      const category = categories.find(c => c.id == categoryId);
      if (!category) return;

      // Convert internal level codes to IONOS format
      // Levels in DB: N3GC, R1, R2, R3, R4, N3, etc.
      // IONOS expects: N3, R1, R2, R3, etc.
      // Remove suffixes like GC, HC, JC, SC from level codes
      const ionosLevel = category.level.toUpperCase().replace(/(GC|HC|JC|SC)$/i, '').trim();

      try {
        const response = await fetch(`${API_URL}/inscriptions/tournoi?mode=${category.game_type}&categorie=${ionosLevel}`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });

        if (response.ok) {
          externalTournois = await response.json();

          // If we have a selected tournament from clicking a card, use its ID directly
          const selectedTournoiId = window.selectedUpcomingTournament?.tournoiId;

          // Find matching tournament - prefer using stored tournoiId if available
          const targetName = tournamentNum === '4' ? 'FINALE' : `TOURNOI ${tournamentNum}`;

          if (selectedTournoiId) {
            // First try to find by exact tournoi_id in the API response
            matchingTournoi = externalTournois.find(t => t.tournoi_id == selectedTournoiId);

            // If not found in filtered results, fetch it directly by ID
            if (!matchingTournoi) {
              try {
                const directResponse = await fetch(`${API_URL}/inscriptions/tournoi/${selectedTournoiId}`, {
                  headers: { 'Authorization': `Bearer ${token}` }
                });
                if (directResponse.ok) {
                  matchingTournoi = await directResponse.json();
                }
              } catch (e) {
                console.log('Could not fetch tournament directly:', e);
              }
            }
          }

          // Fallback to name matching if not found by ID
          if (!matchingTournoi) {
            matchingTournoi = externalTournois.find(t =>
              t.nom.toUpperCase().includes(targetName) ||
              (tournamentNum === '4' && t.nom.toUpperCase().includes('FINALE'))
            );
          }

          if (matchingTournoi) {
            // Load inscription count
            const inscResponse = await fetch(`${API_URL}/inscriptions/tournoi/${matchingTournoi.tournoi_id}/inscriptions`, {
              headers: { 'Authorization': `Bearer ${token}` }
            });
            let inscCount = 0;
            if (inscResponse.ok) {
              const inscriptions = await inscResponse.json();
              inscCount = inscriptions.filter(i => i.forfait !== 1).length;
            }

            // Format date
            const dateStr = matchingTournoi.debut
              ? new Date(matchingTournoi.debut).toLocaleDateString('fr-FR', { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric' })
              : 'Non d√©finie';

            document.getElementById('tournamentInfoName').textContent =
              `${category.display_name} - ${matchingTournoi.nom}`;
            document.getElementById('tournamentInfoDate').textContent = dateStr;
            document.getElementById('tournamentInfoLieu').textContent = matchingTournoi.lieu || 'Non d√©fini';
            // For finals, show "X/Y inscrits" (inscribed finalists / total finalists)
            const isFinaleTournoi = matchingTournoi.nom?.toUpperCase().includes('FINALE') || tournamentNum === 'Finale' || isFinale;
            if (isFinaleTournoi && window.selectedUpcomingTournament) {
              const fc = window.selectedUpcomingTournament.finalist_count || 0;
              const ifc = window.selectedUpcomingTournament.inscribed_finalist_count || 0;
              document.getElementById('tournamentInfoInscrits').textContent = `${ifc}/${fc} inscrits`;
            } else {
              document.getElementById('tournamentInfoInscrits').textContent = `${inscCount} joueurs`;
            }
            document.getElementById('tournamentInfo').style.display = 'block';
          } else if (window.selectedUpcomingTournament && (tournamentNum === 'Finale' || isFinale)) {
            // For finals selected from upcoming tournaments card, use stored data
            const upcomingData = window.selectedUpcomingTournament;

            // Create a pseudo matchingTournoi object for finals
            matchingTournoi = {
              tournoi_id: upcomingData.tournoiId,
              nom: 'Finale D√©partementale',
              debut: upcomingData.date,
              lieu: upcomingData.lieu,
              isFinale: true
            };

            // Load inscription count
            let inscCount = 0;
            if (upcomingData.tournoiId) {
              const inscResponse = await fetch(`${API_URL}/inscriptions/tournoi/${upcomingData.tournoiId}/inscriptions`, {
                headers: { 'Authorization': `Bearer ${token}` }
              });
              if (inscResponse.ok) {
                const inscriptions = await inscResponse.json();
                inscCount = inscriptions.filter(i => i.forfait !== 1).length;
              }
            }

            // Format date
            const dateStr = upcomingData.date
              ? new Date(upcomingData.date).toLocaleDateString('fr-FR', { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric' })
              : 'Non d√©finie';

            document.getElementById('tournamentInfoName').textContent =
              `${category.display_name} - Finale D√©partementale`;
            document.getElementById('tournamentInfoDate').textContent = dateStr;
            document.getElementById('tournamentInfoLieu').textContent = upcomingData.lieu || 'Non d√©fini';
            // For finals, show "X/Y inscrits" (inscribed finalists / total finalists)
            const fc = upcomingData.finalist_count || 0;
            const ifc = upcomingData.inscribed_finalist_count || 0;
            document.getElementById('tournamentInfoInscrits').textContent = `${ifc}/${fc} inscrits`;
            document.getElementById('tournamentInfo').style.display = 'block';
          } else {
            document.getElementById('tournamentInfo').style.display = 'none';
          }
        }
      } catch (error) {
        console.error('Error loading tournament info:', error);
        document.getElementById('tournamentInfo').style.display = 'none';
      }
    }

    document.getElementById('categorySelect').addEventListener('change', updateLoadButtonState);
    document.getElementById('seasonSelect').addEventListener('change', updateLoadButtonState);
    document.getElementById('tournamentSelect').addEventListener('change', updateLoadButtonState);

    // Load players for selected category
    document.getElementById('loadPlayersBtn').addEventListener('click', async () => {
      const categoryId = document.getElementById('categorySelect').value;
      const season = document.getElementById('seasonSelect').value;
      const tournamentNum = document.getElementById('tournamentSelect').value;

      currentCategory = categories.find(c => c.id == categoryId);
      currentSeason = season;
      currentTournament = tournamentNum;

      // Check if this is a finale
      const isFinaleCompetition = isFinale || tournamentNum === 'Finale' || tournamentNum === '4';

      // Determine which ranking to load based on tournament number
      const previousTournament = parseInt(tournamentNum) - 1;

      try {
        // For FINALE: Load full rankings and take top 4 or 6 finalists
        if (isFinaleCompetition) {
          const rankingResponse = await fetch(`${API_URL}/rankings?categoryId=${categoryId}&season=${season}`, {
            headers: { 'Authorization': `Bearer ${token}` }
          });

          if (rankingResponse.ok) {
            const data = await rankingResponse.json();
            const rankings = data.rankings || [];

            // Determine number of finalists: 6 if enough participants, otherwise 4
            // Count unique participants across all 3 tournaments
            const totalParticipants = rankings.length;
            const numFinalists = totalParticipants >= 10 ? 6 : 4;

            // Take only top N finalists
            rankedPlayers = rankings.slice(0, numFinalists).map((r, index) => ({
              licence: r.licence,
              first_name: r.first_name,
              last_name: r.last_name,
              club: r.club,
              rank: r.rank_position,
              total_match_points: r.total_match_points,
              isRanked: true,
              isFinalist: true
            }));
          }
        }
        // For regular tournaments (T2, T3): Load ranking from previous tournament(s)
        else if (previousTournament >= 1) {
          const rankingResponse = await fetch(`${API_URL}/rankings?categoryId=${categoryId}&season=${season}`, {
            headers: { 'Authorization': `Bearer ${token}` }
          });

          if (rankingResponse.ok) {
            const data = await rankingResponse.json();
            const rankings = data.rankings || [];
            rankedPlayers = rankings.map((r, index) => ({
              licence: r.licence,
              first_name: r.first_name,
              last_name: r.last_name,
              club: r.club,
              rank: r.rank_position,
              total_match_points: r.total_match_points,
              isRanked: true
            }));
          }
        } else {
          // T1 - no previous ranking, would need to use player list
          rankedPlayers = [];
        }

        // Load inscriptions using the already-matched tournament
        if (matchingTournoi) {
          const inscriptionsResponse = await fetch(`${API_URL}/inscriptions/tournoi/${matchingTournoi.tournoi_id}/inscriptions`, {
            headers: { 'Authorization': `Bearer ${token}` }
          });

          // Fetch player emails for email convocations
          fetchPlayerEmails(matchingTournoi.tournoi_id);

          if (inscriptionsResponse.ok) {
            const inscriptions = await inscriptionsResponse.json();

            // For FINALE: Don't show "new players" section - only finalists matter
            if (isFinaleCompetition) {
              newPlayers = [];

              // Mark finalists who have inscribed
              rankedPlayers.forEach(p => {
                const inscription = inscriptions.find(i =>
                  i.licence?.replace(/\s/g, '') === p.licence?.replace(/\s/g, '')
                );
                if (inscription) {
                  p.isInscribed = true;
                  p.forfait = inscription.forfait === 1;
                  // Auto-select inscribed finalists (not forfait)
                  if (!p.forfait) {
                    p.selected = true;
                  }
                }
              });
            } else {
              // Regular tournament logic
              // Find new players (inscribed but not in ranking)
              const rankedLicences = new Set(rankedPlayers.map(p => p.licence.replace(/\s/g, '')));

              newPlayers = inscriptions
                .filter(i => !rankedLicences.has(i.licence?.replace(/\s/g, '')) && i.forfait !== 1)
                .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp))
                .map((i, index) => ({
                  licence: i.licence,
                  first_name: i.first_name || 'Inconnu',
                  last_name: i.last_name || 'Inconnu',
                  club: i.club || '',
                  timestamp: i.timestamp,
                  isNew: true,
                  forfait: i.forfait
                }));

              // Mark ranked players who are inscribed or forfait AND auto-select them
              rankedPlayers.forEach(p => {
                const inscription = inscriptions.find(i =>
                  i.licence?.replace(/\s/g, '') === p.licence?.replace(/\s/g, '')
                );
                if (inscription) {
                  p.isInscribed = true;
                  p.forfait = inscription.forfait === 1;
                  // Auto-select inscribed players (not forfait)
                  if (!p.forfait) {
                    p.selected = true;
                  }
                }
              });

              // Auto-select all new players (they are all inscribed by definition)
              newPlayers.forEach(p => {
                p.selected = true;
              });
            }
          }
        } else {
          // No matching external tournament found - clear new players
          newPlayers = [];
        }

        // Load all system players for last minute search (in separate try-catch to avoid breaking main flow)
        try {
          const allPlayersResponse = await fetch(`${API_URL}/players`, {
            headers: { 'Authorization': `Bearer ${token}` }
          });
          if (allPlayersResponse.ok) {
            allSystemPlayers = await allPlayersResponse.json();
          }
        } catch (e) {
          console.error('Error loading all players:', e);
        }

        // Reset last minute players
        lastMinutePlayers = [];
        selectedLastMinutePlayer = null;

        renderPlayerLists();
        goToStep(2);

      } catch (error) {
        console.error('Error loading players:', error);
        document.getElementById('errorMessage').textContent = 'Erreur lors du chargement des joueurs';
        document.getElementById('errorMessage').style.display = 'block';
      }
    });

    // Render player lists
    function renderPlayerLists() {
      const rankedList = document.getElementById('rankedPlayersList');
      const newList = document.getElementById('newPlayersList');
      const rankedTitle = document.getElementById('rankedPlayersTitle');
      const newPlayersTitle = document.getElementById('newPlayersTitle');
      const newPlayersSection = newList.parentElement;

      // Check if this is a finale
      const isFinaleCompetition = isFinale || currentTournament === 'Finale' || currentTournament === '4';

      // Update titles based on competition type
      if (isFinaleCompetition) {
        rankedTitle.textContent = `üèÜ Finalistes qualifi√©s (${rankedPlayers.length} joueurs)`;
        newPlayersTitle.style.display = 'none';
        newList.style.display = 'none';
      } else {
        rankedTitle.textContent = 'Joueurs class√©s (du classement actuel)';
        newPlayersTitle.style.display = 'block';
        newList.style.display = 'block';
      }

      if (rankedPlayers.length === 0) {
        rankedList.innerHTML = isFinaleCompetition
          ? '<p style="padding: 20px; color: #666; text-align: center;">Aucun classement disponible - Impossible de d√©terminer les finalistes</p>'
          : '<p style="padding: 20px; color: #666; text-align: center;">Aucun classement disponible pour ce tournoi</p>';
      } else {
        rankedList.innerHTML = rankedPlayers.map((p, index) => `
          <div class="player-item ${p.selected ? 'selected' : ''} ${p.forfait ? 'forfait' : ''} ${!p.isInscribed && isFinaleCompetition ? 'not-inscribed' : ''}"
               data-licence="${p.licence}" data-type="ranked" data-index="${index}"
               style="${!p.isInscribed && isFinaleCompetition ? 'background: #fff3cd;' : ''}">
            <input type="checkbox" ${p.selected ? 'checked' : ''} ${p.forfait ? 'disabled' : ''}>
            <span class="player-rank">#${p.rank}</span>
            <span class="player-name">${p.last_name} ${p.first_name}</span>
            <span class="player-club">${p.club || ''}</span>
            <span class="player-licence">${p.licence}</span>
            ${p.isFinalist ? '<span class="badge" style="background: #ffc107; color: #333;">Finaliste</span>' : ''}
            ${p.forfait ? '<span class="badge badge-forfait">Forfait</span>' : (p.isInscribed ? '<span class="badge badge-inscrit">Inscrit</span>' : (isFinaleCompetition ? '<span class="badge" style="background: #dc3545; color: white;">Non inscrit</span>' : ''))}
          </div>
        `).join('');
      }

      if (newPlayers.length === 0) {
        newList.innerHTML = '<p style="padding: 20px; color: #666; text-align: center;">Aucun nouveau joueur inscrit</p>';
      } else {
        newList.innerHTML = newPlayers.map((p, index) => `
          <div class="player-item new-player ${p.selected ? 'selected' : ''}"
               data-licence="${p.licence}" data-type="new" data-index="${index}">
            <input type="checkbox" ${p.selected ? 'checked' : ''}>
            <span class="player-rank">-</span>
            <span class="player-name">${p.last_name} ${p.first_name}</span>
            <span class="player-club">${p.club || ''}</span>
            <span class="player-licence">${p.licence}</span>
            <span class="badge badge-new">Nouveau</span>
          </div>
        `).join('');
      }

      // Render last minute players
      const lastMinuteList = document.getElementById('lastMinutePlayersList');
      if (lastMinuteList) {
        if (lastMinutePlayers.length === 0) {
          lastMinuteList.innerHTML = '';
        } else {
          lastMinuteList.innerHTML = lastMinutePlayers.map((p, index) => `
            <div class="player-item new-player ${p.selected ? 'selected' : ''}"
                 data-licence="${p.licence}" data-type="lastMinute" data-index="${index}">
              <input type="checkbox" ${p.selected ? 'checked' : ''}>
              <span class="player-rank">-</span>
              <span class="player-name">${p.last_name} ${p.first_name}</span>
              <span class="player-club">${p.club || ''}</span>
              <span class="player-licence">${p.licence}</span>
              <span class="badge" style="background: #dc3545; color: white;">Last minute</span>
              <button class="btn-remove-lastminute" data-index="${index}" style="margin-left: auto; background: none; border: none; color: #dc3545; cursor: pointer; font-size: 18px;" title="Retirer">√ó</button>
            </div>
          `).join('');

          // Add remove handlers for last minute players
          lastMinuteList.querySelectorAll('.btn-remove-lastminute').forEach(btn => {
            btn.addEventListener('click', (e) => {
              e.stopPropagation();
              const idx = parseInt(btn.dataset.index);
              lastMinutePlayers.splice(idx, 1);
              renderPlayerLists();
            });
          });
        }
      }

      // Add click handlers
      document.querySelectorAll('.player-item').forEach(item => {
        item.addEventListener('click', (e) => {
          if (e.target.type === 'checkbox') return;
          if (item.classList.contains('forfait')) return;

          const checkbox = item.querySelector('input[type="checkbox"]');
          checkbox.checked = !checkbox.checked;
          togglePlayerSelection(item);
        });

        item.querySelector('input[type="checkbox"]').addEventListener('change', () => {
          togglePlayerSelection(item);
        });
      });

      updateSelectionSummary();
    }

    function togglePlayerSelection(item) {
      const type = item.dataset.type;
      const index = parseInt(item.dataset.index);
      const checkbox = item.querySelector('input[type="checkbox"]');

      if (type === 'ranked') {
        rankedPlayers[index].selected = checkbox.checked;
      } else if (type === 'lastMinute') {
        lastMinutePlayers[index].selected = checkbox.checked;
      } else {
        newPlayers[index].selected = checkbox.checked;
      }

      item.classList.toggle('selected', checkbox.checked);
      updateSelectionSummary();
    }

    function updateSelectionSummary() {
      const selectedRanked = rankedPlayers.filter(p => p.selected);
      const selectedNew = newPlayers.filter(p => p.selected);
      const selectedLastMinute = lastMinutePlayers.filter(p => p.selected);
      const totalSelected = selectedRanked.length + selectedNew.length + selectedLastMinute.length;

      document.getElementById('selectedCount').textContent = totalSelected;

      if (totalSelected >= 3) {
        // For finals: always show "1 poule unique" since all finalists play together
        if (isFinale) {
          document.getElementById('pouleConfig').textContent = '1 poule unique (tous contre tous)';
          document.getElementById('tablesNeeded').textContent = '1';
        } else {
          const config = getPouleConfig(totalSelected);
          document.getElementById('pouleConfig').textContent = config.description;
          document.getElementById('tablesNeeded').textContent = config.tables;
        }
        document.getElementById('validatePlayersBtn').disabled = false;
      } else {
        document.getElementById('pouleConfig').textContent = '-';
        document.getElementById('tablesNeeded').textContent = '-';
        document.getElementById('validatePlayersBtn').disabled = true;
      }
    }

    // Selection buttons
    document.getElementById('selectAllBtn').addEventListener('click', () => {
      rankedPlayers.forEach(p => { if (!p.forfait) p.selected = true; });
      newPlayers.forEach(p => p.selected = true);
      lastMinutePlayers.forEach(p => p.selected = true);
      renderPlayerLists();
    });

    document.getElementById('deselectAllBtn').addEventListener('click', () => {
      rankedPlayers.forEach(p => p.selected = false);
      newPlayers.forEach(p => p.selected = false);
      lastMinutePlayers.forEach(p => p.selected = false);
      renderPlayerLists();
    });

    document.getElementById('selectRegisteredBtn').addEventListener('click', () => {
      rankedPlayers.forEach(p => {
        p.selected = p.isInscribed && !p.forfait;
      });
      newPlayers.forEach(p => p.selected = true);
      lastMinutePlayers.forEach(p => p.selected = true);
      renderPlayerLists();
    });

    // Navigation
    function goToStep(stepNum) {
      document.querySelectorAll('.card[id^="step"]').forEach(card => card.style.display = 'none');
      document.getElementById(`step${stepNum}`).style.display = 'block';

      // Hide upcoming tournaments when leaving step 1, show it when returning to step 1
      const upcomingCard = document.getElementById('upcomingTournamentsCard');
      if (upcomingCard) {
        upcomingCard.style.display = stepNum === 1 ? 'block' : 'none';
      }

      document.querySelectorAll('.step').forEach((step, index) => {
        step.classList.remove('active', 'completed');
        if (index + 1 < stepNum) step.classList.add('completed');
        if (index + 1 === stepNum) step.classList.add('active');
      });
    }

    document.getElementById('backToStep1Btn').addEventListener('click', () => goToStep(1));
    document.getElementById('backToStep2Btn').addEventListener('click', () => goToStep(2));
    document.getElementById('backToStep3Btn').addEventListener('click', () => goToStep(3));
    document.getElementById('newGenerationBtn').addEventListener('click', () => {
      // Reset state
      rankedPlayers = [];
      newPlayers = [];
      lastMinutePlayers = [];
      selectedPlayers = [];
      goToStep(1);
    });

    // Validate and preview
    document.getElementById('validatePlayersBtn').addEventListener('click', () => {
      // Build final player list with re-ranking
      selectedPlayers = [];

      // First add selected ranked players (maintaining their rank order but re-numbering)
      let newRank = 1;
      rankedPlayers.filter(p => p.selected).forEach(p => {
        selectedPlayers.push({
          ...p,
          finalRank: newRank++
        });
      });

      // Then add new players sorted by timestamp
      newPlayers.filter(p => p.selected).forEach(p => {
        selectedPlayers.push({
          ...p,
          finalRank: newRank++
        });
      });

      // Then add last minute players
      lastMinutePlayers.filter(p => p.selected).forEach(p => {
        selectedPlayers.push({
          ...p,
          finalRank: newRank++,
          isLastMinute: true
        });
      });

      // Update summary
      document.getElementById('summaryCategory').textContent = currentCategory.display_name;
      const isFinale = currentTournament === 'Finale' || currentTournament === '4' ||
                       (window.selectedUpcomingTournament && window.selectedUpcomingTournament.isFinale);
      document.getElementById('summaryTournament').textContent =
        isFinale ? 'Finale D√©partementale' : `Tournoi ${currentTournament}`;

      // Store isFinale globally for later use
      window.currentCompetitionIsFinale = isFinale;

      // Add tournament date and lieu from external tournament
      if (matchingTournoi) {
        const dateStr = matchingTournoi.debut
          ? new Date(matchingTournoi.debut).toLocaleDateString('fr-FR', { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric' })
          : 'Non d√©finie';
        document.getElementById('summaryDate').textContent = dateStr;
        document.getElementById('summaryLieu').textContent = matchingTournoi.lieu || 'Non d√©fini';
      } else {
        document.getElementById('summaryDate').textContent = 'Non d√©finie';
        document.getElementById('summaryLieu').textContent = 'Non d√©fini';
      }

      document.getElementById('summaryPlayers').textContent = selectedPlayers.length;

      let poules;
      let configDescription;
      let tablesNeeded;

      if (isFinale) {
        // For finals: single poule with all players (no serpentine distribution)
        poules = [{
          number: 1,
          size: selectedPlayers.length,
          players: selectedPlayers.map((p, idx) => ({
            ...p,
            pouleRank: idx + 1
          }))
        }];
        configDescription = `1 poule unique de ${selectedPlayers.length} joueurs (Finale)`;
        tablesNeeded = 1;

        // Update the poule preview title for finale
        document.getElementById('poulePreviewTitle').innerHTML = 'Aper√ßu de la Poule Unique (Finale - Tous contre tous)';
      } else {
        // For regular tournaments: serpentine distribution
        const config = getPouleConfig(selectedPlayers.length);
        poules = distributeSerpentine(selectedPlayers, config.poules);
        configDescription = config.description;
        tablesNeeded = config.tables;

        // Reset the poule preview title
        document.getElementById('poulePreviewTitle').innerHTML = 'Aper√ßu des Poules (Distribution Serpentine)';
      }

      document.getElementById('summaryConfig').textContent = configDescription;
      document.getElementById('summaryTables').textContent = tablesNeeded;

      // Generate poule preview
      renderPoulePreview(poules);

      // Pre-select location from tournament file
      if (matchingTournoi && matchingTournoi.lieu) {
        preselectLocation(matchingTournoi.lieu);
      }

      // Reset second location
      document.getElementById('location2Container').style.display = 'none';
      document.getElementById('addLocation2Btn').style.display = 'inline-block';
      document.getElementById('locationSelect2').value = '';

      // Load game parameters for this category
      loadGameParameters();

      goToStep(3);
    });

    // Load and display game parameters for the current category
    async function loadGameParameters() {
      if (!currentCategory) {
        document.getElementById('gameParamsSection').style.display = 'none';
        return;
      }

      try {
        const response = await fetch(`${API_URL}/settings/game-parameters/${currentCategory.game_type}/${currentCategory.level}`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });

        if (!response.ok) {
          document.getElementById('gameParamsSection').style.display = 'none';
          currentGameParams = null;
          return;
        }

        currentGameParams = await response.json();

        // Show the game parameters section
        document.getElementById('gameParamsSection').style.display = 'block';

        // Update distance selector
        const distanceSelect = document.getElementById('distanceSelect');
        distanceSelect.innerHTML = `<option value="normale">${currentGameParams.distance_normale} points (Distance normale)</option>`;
        if (currentGameParams.distance_reduite) {
          distanceSelect.innerHTML += `<option value="reduite">${currentGameParams.distance_reduite} points (Distance r√©duite)</option>`;
        }

        // Update coin display
        const coinSpan = document.getElementById('gameParamCoin');
        coinSpan.textContent = currentGameParams.coin === 'GC' ? 'Grand Coin' : 'Petit Coin';
        coinSpan.style.background = currentGameParams.coin === 'GC' ? '#ffc107' : '#17a2b8';
        coinSpan.style.color = currentGameParams.coin === 'GC' ? '#000' : '#fff';

        // Update reprises
        document.getElementById('gameParamReprises').textContent = currentGameParams.reprises;

        // Update moyenne info
        document.getElementById('gameParamMoyenne').textContent =
          `La moyenne qualificative pour cette cat√©gorie est entre ${parseFloat(currentGameParams.moyenne_mini).toFixed(3)} et ${parseFloat(currentGameParams.moyenne_maxi).toFixed(3)}`;

      } catch (error) {
        console.error('Error loading game parameters:', error);
        document.getElementById('gameParamsSection').style.display = 'none';
        currentGameParams = null;
      }
    }

    // Store current poules globally for manipulation
    let currentPoules = [];

    function renderPoulePreview(poules) {
      currentPoules = poules;
      const container = document.getElementById('poulePreview');
      const numPoules = poules.length;

      container.innerHTML = poules.map(poule => `
        <div class="poule-card" data-poule="${poule.number}">
          <h4>Poule ${poule.number} (${poule.players.length} joueurs)</h4>
          ${poule.players.map((p, index) => `
            <div class="poule-player" data-licence="${p.licence}" data-poule="${poule.number}">
              <span class="poule-player-rank">${index + 1}.</span>
              <span style="flex: 1;">${p.last_name} ${p.first_name} <strong style="color: #1F4788;">(${p.finalRank})</strong></span>
              ${p.isLastMinute ? '<span class="badge" style="background: #dc3545; color: white;">Last minute</span>' : (p.isNew ? '<span class="badge badge-new">Nouveau</span>' : '')}
              ${numPoules > 1 ? `
                <select class="move-player-select" data-licence="${p.licence}" data-from-poule="${poule.number}"
                        style="padding: 2px 5px; font-size: 0.75em; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;">
                  <option value="">D√©placer...</option>
                  ${poules.filter(op => op.number !== poule.number).map(op =>
                    `<option value="${op.number}">‚Üí Poule ${op.number}</option>`
                  ).join('')}
                </select>
              ` : ''}
            </div>
          `).join('')}
          <div class="poule-location-select" style="margin-top: 10px; padding-top: 10px; border-top: 1px dashed #ddd;">
            <select class="poule-location" data-poule="${poule.number}" style="width: 100%; padding: 5px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.85em;">
              <option value="1">Lieu 1</option>
              <option value="2">Lieu 2</option>
            </select>
          </div>
        </div>
      `).join('');

      // Add move player handlers
      container.querySelectorAll('.move-player-select').forEach(select => {
        select.addEventListener('change', (e) => {
          const licence = select.dataset.licence;
          const fromPoule = parseInt(select.dataset.fromPoule);
          const toPoule = parseInt(e.target.value);

          if (toPoule) {
            movePlayerBetweenPoules(licence, fromPoule, toPoule);
          }
          // Reset select
          select.value = '';
        });
      });

      // Update location labels when locations change
      updatePouleLocationLabels();
    }

    function movePlayerBetweenPoules(licence, fromPouleNum, toPouleNum) {
      // Find the player in the source poule
      const fromPoule = currentPoules.find(p => p.number === fromPouleNum);
      const toPoule = currentPoules.find(p => p.number === toPouleNum);

      if (!fromPoule || !toPoule) return;

      const playerIndex = fromPoule.players.findIndex(p => p.licence === licence);
      if (playerIndex === -1) return;

      // Remove from source poule
      const [player] = fromPoule.players.splice(playerIndex, 1);

      // Add to destination poule
      toPoule.players.push(player);

      // Re-render
      renderPoulePreview(currentPoules);

      // Show success message briefly
      const msg = document.getElementById('successMessage');
      msg.textContent = `${player.last_name} ${player.first_name} d√©plac√© vers Poule ${toPouleNum}`;
      msg.style.display = 'block';
      setTimeout(() => msg.style.display = 'none', 2000);
    }

    function updatePouleLocationLabels() {
      const location1Select = document.getElementById('locationSelect1');
      const location2Select = document.getElementById('locationSelect2');
      const location2Container = document.getElementById('location2Container');

      const loc1Name = location1Select.value ?
        location1Select.options[location1Select.selectedIndex]?.text : 'Lieu 1';
      const loc2Name = location2Select.value ?
        location2Select.options[location2Select.selectedIndex]?.text : 'Lieu 2';

      const hasSecondLocation = location2Container.style.display !== 'none' && location2Select.value;

      document.querySelectorAll('.poule-location').forEach(select => {
        select.innerHTML = `
          <option value="1">${loc1Name || 'Lieu 1'}</option>
          ${hasSecondLocation ? `<option value="2">${loc2Name || 'Lieu 2'}</option>` : ''}
        `;
      });
    }

    // Generate Excel
    document.getElementById('generateExcelBtn').addEventListener('click', async () => {
      const config = getPouleConfig(selectedPlayers.length);
      // Use currentPoules which may have been modified by moving players
      const poules = currentPoules.length > 0 ? currentPoules : distributeSerpentine(selectedPlayers, config.poules);

      // Get selected locations and times
      const location1Select = document.getElementById('locationSelect1');
      const loc1Option = location1Select.options[location1Select.selectedIndex];
      const location1 = location1Select.value ? {
        id: location1Select.value,
        name: loc1Option.dataset.name,
        street: loc1Option.dataset.street,
        city: loc1Option.dataset.city,
        zip_code: loc1Option.dataset.zipcode,
        phone: loc1Option.dataset.phone,
        email: loc1Option.dataset.email,
        address: loc1Option.dataset.address
      } : null;

      const location2Select = document.getElementById('locationSelect2');
      const loc2Option = location2Select.options[location2Select.selectedIndex];
      const location2 = location2Select.value ? {
        id: location2Select.value,
        name: loc2Option.dataset.name,
        street: loc2Option.dataset.street,
        city: loc2Option.dataset.city,
        zip_code: loc2Option.dataset.zipcode,
        phone: loc2Option.dataset.phone,
        email: loc2Option.dataset.email,
        address: loc2Option.dataset.address
      } : null;

      const startTime1 = document.getElementById('startTime1').value || '13:30';
      const startTime2 = document.getElementById('startTime2').value || '13:30';

      // Get poule location assignments
      const pouleAssignments = {};
      document.querySelectorAll('.poule-location').forEach(select => {
        const pouleNum = select.dataset.poule;
        pouleAssignments[pouleNum] = select.value; // '1' or '2'
      });

      // Add location assignment to each poule
      poules.forEach(poule => {
        poule.locationNum = pouleAssignments[poule.number] || '1';
      });

      try {
        const response = await fetch(`${API_URL}/inscriptions/generate-poules`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            category: currentCategory,
            season: currentSeason,
            tournament: currentTournament,
            players: selectedPlayers,
            poules: poules,
            config: config,
            tournamentDate: matchingTournoi?.debut || null,
            tournamentLieu: matchingTournoi?.lieu || null,
            locations: [
              location1 ? { ...location1, startTime: startTime1, locationNum: '1' } : null,
              location2 ? { ...location2, startTime: startTime2, locationNum: '2' } : null
            ].filter(Boolean)
          })
        });

        if (response.ok) {
          // Download the file
          const blob = await response.blob();
          const url = window.URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `Poules_${currentCategory.display_name}_T${currentTournament}_${currentSeason}.xlsx`;
          document.body.appendChild(a);
          a.click();
          a.remove();
          window.URL.revokeObjectURL(url);

          // Store data for email functionality
          const selectedDistance = document.getElementById('distanceSelect')?.value || 'normale';
          storeGenerationData({
            poules: poules,
            tournamentDate: matchingTournoi?.debut || null,
            tournoiId: matchingTournoi?.tournoi_id || null,
            locations: [
              location1 ? { ...location1, startTime: startTime1, locationNum: '1' } : null,
              location2 ? { ...location2, startTime: startTime2, locationNum: '2' } : null
            ].filter(Boolean),
            gameParams: currentGameParams,
            selectedDistance: selectedDistance
          });

          goToStep(4);
          updateEmailStats();
        } else {
          const error = await response.json();
          document.getElementById('errorMessage').textContent = error.error || 'Erreur lors de la g√©n√©ration';
          document.getElementById('errorMessage').style.display = 'block';
        }
      } catch (error) {
        console.error('Error generating Excel:', error);
        document.getElementById('errorMessage').textContent = 'Erreur lors de la g√©n√©ration du fichier';
        document.getElementById('errorMessage').style.display = 'block';
      }
    });

    // Generate Summary PDF (neutral - no personalization)
    document.getElementById('generateSummaryPdfBtn').addEventListener('click', async () => {
      const config = getPouleConfig(selectedPlayers.length);
      const poules = currentPoules.length > 0 ? currentPoules : distributeSerpentine(selectedPlayers, config.poules);

      // Get selected locations and times
      const location1Select = document.getElementById('locationSelect1');
      const loc1Option = location1Select.options[location1Select.selectedIndex];
      const location1 = location1Select.value ? {
        id: location1Select.value,
        name: loc1Option.dataset.name,
        street: loc1Option.dataset.street,
        city: loc1Option.dataset.city,
        zip_code: loc1Option.dataset.zipcode
      } : null;

      const location2Select = document.getElementById('locationSelect2');
      const loc2Option = location2Select.options[location2Select.selectedIndex];
      const location2 = location2Select.value ? {
        id: location2Select.value,
        name: loc2Option.dataset.name,
        street: loc2Option.dataset.street,
        city: loc2Option.dataset.city,
        zip_code: loc2Option.dataset.zipcode
      } : null;

      const startTime1 = document.getElementById('startTime1').value || '13:30';
      const startTime2 = document.getElementById('startTime2').value || '13:30';

      // Get poule location assignments
      const pouleAssignments = {};
      document.querySelectorAll('.poule-location').forEach(select => {
        const pouleNum = select.dataset.poule;
        pouleAssignments[pouleNum] = select.value;
      });

      poules.forEach(poule => {
        poule.locationNum = pouleAssignments[poule.number] || '1';
      });

      const selectedDistance = document.getElementById('distanceSelect')?.value || 'normale';

      // Check for TEST players and inject mock ranking data
      const hasTestPlayers = poules.some(p => p.players.some(pl => pl.licence?.startsWith('TEST')));
      let mockRankingData = null;
      if (hasTestPlayers) {
        mockRankingData = {
          'TEST001': { rank: 1, moyenne: '2.098' },
          'TEST002': { rank: 2, moyenne: '2.057' },
          'TEST003': { rank: 3, moyenne: '1.985' },
          'TEST004': { rank: 4, moyenne: '1.876' },
          'TEST005': { rank: 5, moyenne: '1.754' },
          'TEST006': { rank: 6, moyenne: '1.698' },
          'TEST007': { rank: 7, moyenne: '1.623' },
          'TEST008': { rank: 8, moyenne: '1.567' },
          'TEST009': { rank: 9, moyenne: '1.498' },
          'TEST010': { rank: 10, moyenne: '1.432' },
          'TEST011': { rank: 11, moyenne: '1.387' },
          'TEST012': { rank: 12, moyenne: '1.298' }
        };
      }

      try {
        const response = await fetch(`${API_URL}/email/generate-summary-pdf`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            category: currentCategory,
            season: currentSeason,
            tournament: currentTournament,
            poules: poules,
            tournamentDate: matchingTournoi?.debut || null,
            locations: [
              location1 ? { ...location1, startTime: startTime1, locationNum: '1' } : null,
              location2 ? { ...location2, startTime: startTime2, locationNum: '2' } : null
            ].filter(Boolean),
            gameParams: currentGameParams,
            selectedDistance: selectedDistance,
            mockRankingData: mockRankingData,
            isFinale: isFinale
          })
        });

        if (response.ok) {
          const blob = await response.blob();
          const url = window.URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `Convocation_${currentCategory.display_name.replace(/\s+/g, '_')}_T${currentTournament}_${currentSeason}.pdf`;
          document.body.appendChild(a);
          a.click();
          a.remove();
          window.URL.revokeObjectURL(url);

          document.getElementById('successMessage').textContent = 'PDF r√©capitulatif t√©l√©charg√© !';
          document.getElementById('successMessage').style.display = 'block';
          setTimeout(() => {
            document.getElementById('successMessage').style.display = 'none';
          }, 3000);
        } else {
          const error = await response.json();
          document.getElementById('errorMessage').textContent = error.error || 'Erreur lors de la g√©n√©ration du PDF';
          document.getElementById('errorMessage').style.display = 'block';
        }
      } catch (error) {
        console.error('Error generating Summary PDF:', error);
        document.getElementById('errorMessage').textContent = 'Erreur lors de la g√©n√©ration du PDF';
        document.getElementById('errorMessage').style.display = 'block';
      }
    });

    // Last minute player search
    const lastMinuteSearch = document.getElementById('lastMinuteSearch');
    const lastMinuteResults = document.getElementById('lastMinuteResults');
    const addLastMinuteBtn = document.getElementById('addLastMinuteBtn');

    lastMinuteSearch.addEventListener('input', () => {
      const query = lastMinuteSearch.value.trim().toLowerCase();

      if (query.length < 2) {
        lastMinuteResults.style.display = 'none';
        selectedLastMinutePlayer = null;
        addLastMinuteBtn.disabled = true;
        return;
      }

      // Get already selected licences
      const selectedLicences = new Set([
        ...rankedPlayers.filter(p => p.selected).map(p => p.licence?.replace(/\s/g, '')),
        ...newPlayers.filter(p => p.selected).map(p => p.licence?.replace(/\s/g, '')),
        ...lastMinutePlayers.map(p => p.licence?.replace(/\s/g, ''))
      ]);

      // Search in all system players
      const results = allSystemPlayers
        .filter(p => {
          const fullName = `${p.last_name} ${p.first_name}`.toLowerCase();
          const licence = (p.licence || '').toLowerCase();
          return (fullName.includes(query) || licence.includes(query)) &&
                 !selectedLicences.has(p.licence?.replace(/\s/g, ''));
        })
        .slice(0, 10);

      if (results.length === 0) {
        lastMinuteResults.innerHTML = '<p style="padding: 10px; color: #666;">Aucun joueur trouv√©</p>';
        lastMinuteResults.style.display = 'block';
        return;
      }

      lastMinuteResults.innerHTML = results.map(p => `
        <div class="search-result-item" data-licence="${p.licence}"
             style="padding: 10px 15px; border-bottom: 1px solid #eee; cursor: pointer; transition: background 0.2s;">
          <strong>${p.last_name} ${p.first_name}</strong>
          <span style="color: #666; margin-left: 10px;">${p.club || ''}</span>
          <span style="color: #999; margin-left: 10px; font-size: 0.85em;">${p.licence}</span>
        </div>
      `).join('');

      lastMinuteResults.style.display = 'block';

      // Add click handlers to search results
      lastMinuteResults.querySelectorAll('.search-result-item').forEach(item => {
        item.addEventListener('mouseover', () => item.style.background = '#f5f5f5');
        item.addEventListener('mouseout', () => {
          if (selectedLastMinutePlayer?.licence !== item.dataset.licence) {
            item.style.background = '';
          }
        });
        item.addEventListener('click', () => {
          // Deselect previous
          lastMinuteResults.querySelectorAll('.search-result-item').forEach(i => i.style.background = '');

          // Select this one
          item.style.background = '#e3f2fd';
          selectedLastMinutePlayer = allSystemPlayers.find(p => p.licence === item.dataset.licence);
          addLastMinuteBtn.disabled = false;
        });
      });
    });

    // Get the rank field name for a game type
    function getRankFieldForGameType(gameType) {
      const mapping = {
        'LIBRE': 'rank_libre',
        '3BANDES': 'rank_3bandes',
        '3 BANDES': 'rank_3bandes',
        'BANDE': 'rank_bande',
        '1BANDE': 'rank_bande',
        '1 BANDE': 'rank_bande',
        'CADRE': 'rank_cadre'
      };
      return mapping[gameType.toUpperCase()] || 'rank_libre';
    }

    // Check if player's rank matches the tournament category
    function checkPlayerCategory(player, category) {
      if (!category) return { matches: true };

      const rankField = getRankFieldForGameType(category.game_type);
      const playerRank = player[rankField] || 'NC';
      const tournamentLevel = category.level.toUpperCase();

      // NC (Non Class√©) is considered not matching any specific level
      if (playerRank === 'NC' || playerRank.toUpperCase() === 'NC') {
        return {
          matches: false,
          playerRank: 'NC (Non Class√©)',
          expectedLevel: tournamentLevel,
          gameType: category.game_type
        };
      }

      // Check if ranks match
      const matches = playerRank.toUpperCase() === tournamentLevel;
      return {
        matches,
        playerRank: playerRank,
        expectedLevel: tournamentLevel,
        gameType: category.game_type
      };
    }

    addLastMinuteBtn.addEventListener('click', () => {
      if (!selectedLastMinutePlayer) return;

      // Check if player's category matches the tournament
      const categoryCheck = checkPlayerCategory(selectedLastMinutePlayer, currentCategory);

      if (!categoryCheck.matches) {
        const playerName = `${selectedLastMinutePlayer.first_name} ${selectedLastMinutePlayer.last_name}`;
        const message = `‚ö†Ô∏è Attention: ${playerName} a le classement "${categoryCheck.playerRank}" en ${categoryCheck.gameType}, mais ce tournoi est pour la cat√©gorie "${categoryCheck.expectedLevel}".\n\nVoulez-vous quand m√™me l'ajouter ?`;

        if (!confirm(message)) {
          return; // User cancelled, don't add the player
        }
      }

      // Add to last minute players
      lastMinutePlayers.push({
        licence: selectedLastMinutePlayer.licence,
        first_name: selectedLastMinutePlayer.first_name,
        last_name: selectedLastMinutePlayer.last_name,
        club: selectedLastMinutePlayer.club || '',
        isNew: true,
        isLastMinute: true,
        selected: true
      });

      // Reset search
      lastMinuteSearch.value = '';
      lastMinuteResults.style.display = 'none';
      selectedLastMinutePlayer = null;
      addLastMinuteBtn.disabled = true;

      renderPlayerLists();
    });

    // ==========================================
    // EMAIL CONVOCATIONS FUNCTIONALITY
    // ==========================================

    // Store player emails from inscriptions
    let playerEmails = {};
    let lastGeneratedData = null;

    // Update email stats and populate checkbox list when reaching step 4
    function updateEmailStats() {
      const checkboxList = document.getElementById('playerCheckboxList');
      checkboxList.innerHTML = '';

      let emailableCount = 0;
      const playersWithEmailInfo = selectedPlayers.map(p => {
        const email = p.email || playerEmails[p.licence?.replace(/\s/g, '')];
        const hasEmail = email && email.includes('@');
        if (hasEmail) emailableCount++;
        return { ...p, email, hasEmail };
      });

      // Sort: players with email first
      playersWithEmailInfo.sort((a, b) => {
        if (a.hasEmail && !b.hasEmail) return -1;
        if (!a.hasEmail && b.hasEmail) return 1;
        return (a.last_name || '').localeCompare(b.last_name || '');
      });

      // Create checkboxes for each player
      playersWithEmailInfo.forEach(p => {
        const div = document.createElement('div');
        div.style.cssText = 'display: flex; align-items: center; padding: 8px; border-bottom: 1px solid #eee;';
        div.id = `row_${p.licence?.replace(/\s/g, '')}`;

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `player_${p.licence?.replace(/\s/g, '')}`;
        checkbox.dataset.licence = p.licence?.replace(/\s/g, '');
        checkbox.checked = p.hasEmail; // Checked by default if has email
        checkbox.disabled = !p.hasEmail; // Disabled if no email
        checkbox.style.cssText = 'width: 18px; height: 18px; margin-right: 10px; cursor: pointer;';
        checkbox.addEventListener('change', updateCheckedCount);

        const label = document.createElement('label');
        label.htmlFor = checkbox.id;
        label.id = `label_${p.licence?.replace(/\s/g, '')}`;
        label.style.cssText = `flex: 1; cursor: pointer; ${!p.hasEmail ? 'color: #999;' : ''}`;
        label.innerHTML = `<strong>${p.last_name || ''} ${p.first_name || ''}</strong> - ${p.hasEmail ? p.email : '<em>Pas d\'email</em>'}`;

        // Edit button
        const editBtn = document.createElement('button');
        editBtn.type = 'button';
        editBtn.innerHTML = '‚úèÔ∏è';
        editBtn.title = 'Modifier l\'email';
        editBtn.style.cssText = 'background: none; border: none; cursor: pointer; font-size: 16px; padding: 4px 8px;';
        editBtn.onclick = () => showEmailEditor(p.licence?.replace(/\s/g, ''), p.last_name, p.first_name, p.email || '');

        div.appendChild(checkbox);
        div.appendChild(label);
        div.appendChild(editBtn);
        checkboxList.appendChild(div);
      });

      document.getElementById('emailableCount').textContent = emailableCount;
      document.getElementById('totalPlayersCount').textContent = selectedPlayers.length;
      updateCheckedCount();

      // Disable button if no emails
      document.getElementById('sendConvocationsBtn').disabled = emailableCount === 0;
    }

    // Update checked count display
    function updateCheckedCount() {
      const checkboxes = document.querySelectorAll('#playerCheckboxList input[type="checkbox"]:checked');
      document.getElementById('checkedCount').textContent = checkboxes.length;
      document.getElementById('sendConvocationsBtn').disabled = checkboxes.length === 0;
    }

    // Show email editor inline
    function showEmailEditor(licence, lastName, firstName, currentEmail) {
      const row = document.getElementById(`row_${licence}`);
      if (!row) return;

      // Replace row content with editor
      const originalContent = row.innerHTML;
      row.innerHTML = `
        <div style="flex: 1; display: flex; align-items: center; gap: 8px;">
          <strong>${lastName || ''} ${firstName || ''}</strong>
          <input type="email" id="emailInput_${licence}" value="${currentEmail}"
                 placeholder="email@exemple.com"
                 style="flex: 1; padding: 6px 10px; border: 1px solid #1F4788; border-radius: 4px; font-size: 14px;">
          <button type="button" onclick="saveEmail('${licence}', '${lastName}', '${firstName}')"
                  style="background: #28a745; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer;">
            ‚úì
          </button>
          <button type="button" onclick="cancelEmailEdit('${licence}')"
                  style="background: #dc3545; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer;">
            ‚úó
          </button>
        </div>
      `;
      row.dataset.originalContent = originalContent;

      // Focus the input
      setTimeout(() => {
        const input = document.getElementById(`emailInput_${licence}`);
        if (input) {
          input.focus();
          input.select();
        }
      }, 50);
    }

    // Save edited email
    function saveEmail(licence, lastName, firstName) {
      const input = document.getElementById(`emailInput_${licence}`);
      const newEmail = input?.value?.trim() || '';

      if (newEmail && !newEmail.includes('@')) {
        alert('Veuillez entrer un email valide');
        return;
      }

      // Store in playerEmails object (temporary for this session)
      if (newEmail) {
        playerEmails[licence] = newEmail;
      } else {
        delete playerEmails[licence];
      }

      // Update the row display
      const row = document.getElementById(`row_${licence}`);
      const hasEmail = newEmail && newEmail.includes('@');

      row.innerHTML = '';

      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.id = `player_${licence}`;
      checkbox.dataset.licence = licence;
      checkbox.checked = hasEmail;
      checkbox.disabled = !hasEmail;
      checkbox.style.cssText = 'width: 18px; height: 18px; margin-right: 10px; cursor: pointer;';
      checkbox.addEventListener('change', updateCheckedCount);

      const label = document.createElement('label');
      label.htmlFor = checkbox.id;
      label.id = `label_${licence}`;
      label.style.cssText = `flex: 1; cursor: pointer; ${!hasEmail ? 'color: #999;' : ''}`;
      label.innerHTML = `<strong>${lastName || ''} ${firstName || ''}</strong> - ${hasEmail ? newEmail : '<em>Pas d\'email</em>'}`;

      const editBtn = document.createElement('button');
      editBtn.type = 'button';
      editBtn.innerHTML = '‚úèÔ∏è';
      editBtn.title = 'Modifier l\'email';
      editBtn.style.cssText = 'background: none; border: none; cursor: pointer; font-size: 16px; padding: 4px 8px;';
      editBtn.onclick = () => showEmailEditor(licence, lastName, firstName, newEmail);

      row.appendChild(checkbox);
      row.appendChild(label);
      row.appendChild(editBtn);

      // Update counts
      updateEmailCounts();
      updateCheckedCount();
    }

    // Cancel email edit
    function cancelEmailEdit(licence) {
      const row = document.getElementById(`row_${licence}`);
      if (row && row.dataset.originalContent) {
        row.innerHTML = row.dataset.originalContent;
      } else {
        // Refresh the whole list
        updateEmailStats();
      }
    }

    // Update emailable count after edit
    function updateEmailCounts() {
      let emailableCount = 0;
      selectedPlayers.forEach(p => {
        const email = p.email || playerEmails[p.licence?.replace(/\s/g, '')];
        if (email && email.includes('@')) emailableCount++;
      });
      document.getElementById('emailableCount').textContent = emailableCount;
      document.getElementById('totalPlayersCount').textContent = selectedPlayers.length;
      document.getElementById('sendConvocationsBtn').disabled = emailableCount === 0;
    }

    // Select all / Deselect all buttons for email section
    document.getElementById('emailSelectAllBtn').addEventListener('click', () => {
      document.querySelectorAll('#playerCheckboxList input[type="checkbox"]:not(:disabled)').forEach(cb => cb.checked = true);
      updateCheckedCount();
    });

    document.getElementById('emailDeselectAllBtn').addEventListener('click', () => {
      document.querySelectorAll('#playerCheckboxList input[type="checkbox"]').forEach(cb => cb.checked = false);
      updateCheckedCount();
    });

    // Store the data used for generation so we can use it for emails
    function storeGenerationData(data) {
      lastGeneratedData = data;
    }

    // Send convocations
    document.getElementById('sendConvocationsBtn').addEventListener('click', async () => {
      if (!lastGeneratedData) {
        alert('Veuillez d\'abord g√©n√©rer le fichier Excel');
        return;
      }

      const btn = document.getElementById('sendConvocationsBtn');
      const progress = document.getElementById('emailProgress');
      const progressBar = document.getElementById('emailProgressBar');
      const progressText = document.getElementById('emailProgressText');
      const results = document.getElementById('emailResults');

      // Get selected players from checkboxes
      const checkedLicences = [];
      document.querySelectorAll('#playerCheckboxList input[type="checkbox"]:checked').forEach(cb => {
        checkedLicences.push(cb.dataset.licence);
      });

      if (checkedLicences.length === 0) {
        alert('Veuillez s√©lectionner au moins un joueur');
        return;
      }

      // Confirm
      if (!confirm(`Envoyer les convocations √† ${checkedLicences.length} joueur(s) s√©lectionn√©(s) ?`)) {
        return;
      }

      // Disable button and show progress
      btn.disabled = true;
      btn.textContent = 'Envoi en cours...';
      progress.style.display = 'block';
      results.style.display = 'none';
      progressBar.style.width = '10%';
      progressText.textContent = 'Pr√©paration des emails...';

      try {
        // Filter to only checked players and add emails
        const playersWithEmails = selectedPlayers
          .filter(p => checkedLicences.includes(p.licence?.replace(/\s/g, '')))
          .map(p => {
            const email = p.email || playerEmails[p.licence?.replace(/\s/g, '')];
            return { ...p, email };
          });

        progressBar.style.width = '30%';
        progressText.textContent = 'Envoi des convocations...';

        // Check if we have test players (TEST*) and inject mock ranking data for testing
        const hasTestPlayers = playersWithEmails.some(p => p.licence?.startsWith('TEST'));
        let mockRankingData = null;
        if (hasTestPlayers) {
          mockRankingData = {
            'TEST001': { rank: 1, moyenne: '2.098' },
            'TEST002': { rank: 2, moyenne: '2.057' },
            'TEST003': { rank: 3, moyenne: '2.697' },
            'TEST004': { rank: 4, moyenne: '1.856' },
            'TEST005': { rank: 5, moyenne: '1.542' },
            'TEST006': { rank: 6, moyenne: '1.234' }
          };
          console.log('Test players detected, using mock ranking data');
        }

        const response = await fetch(`${API_URL}/email/send-convocations`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            players: playersWithEmails,
            poules: lastGeneratedData.poules,
            category: currentCategory,
            season: currentSeason,
            tournament: currentTournament,
            tournamentDate: lastGeneratedData.tournamentDate,
            tournoiId: lastGeneratedData.tournoiId,
            locations: lastGeneratedData.locations,
            specialNote: document.getElementById('specialNoteField').value.trim(),
            gameParams: lastGeneratedData.gameParams,
            selectedDistance: lastGeneratedData.selectedDistance,
            mockRankingData: mockRankingData,
            isFinale: window.currentCompetitionIsFinale || false
          })
        });

        progressBar.style.width = '100%';

        const result = await response.json();

        if (response.ok) {
          progressText.textContent = `Emails envoy√©s: ${result.results.sent.length}, √âchecs: ${result.results.failed.length}, Ignor√©s: ${result.results.skipped.length}`;
          progressText.style.color = '#28a745';

          // Show results
          results.style.display = 'block';
          results.innerHTML = '';

          if (result.results.sent.length > 0) {
            results.innerHTML += `<div style="background: #d4edda; padding: 10px; border-radius: 4px; margin-bottom: 10px;">
              <strong>‚úÖ Envoy√©s (${result.results.sent.length}):</strong>
              <ul style="margin: 5px 0 0 20px;">${result.results.sent.map(s => `<li>${s.name} - ${s.email}</li>`).join('')}</ul>
            </div>`;
          }

          if (result.results.failed.length > 0) {
            results.innerHTML += `<div style="background: #f8d7da; padding: 10px; border-radius: 4px; margin-bottom: 10px;">
              <strong>‚ùå √âchecs (${result.results.failed.length}):</strong>
              <ul style="margin: 5px 0 0 20px;">${result.results.failed.map(f => `<li>${f.name} - ${f.error}</li>`).join('')}</ul>
            </div>`;
          }

          if (result.results.skipped.length > 0) {
            results.innerHTML += `<div style="background: #fff3cd; padding: 10px; border-radius: 4px;">
              <strong>‚ö†Ô∏è Ignor√©s (${result.results.skipped.length}):</strong>
              <ul style="margin: 5px 0 0 20px;">${result.results.skipped.map(s => `<li>${s.name} - ${s.reason}</li>`).join('')}</ul>
            </div>`;
          }
        } else {
          progressText.textContent = `Erreur: ${result.error}`;
          progressText.style.color = '#dc3545';
        }
      } catch (error) {
        console.error('Error sending emails:', error);
        progressBar.style.width = '100%';
        progressText.textContent = `Erreur: ${error.message}`;
        progressText.style.color = '#dc3545';
      }

      // Re-enable button
      btn.disabled = false;
      btn.textContent = '‚úâÔ∏è Envoyer les convocations';
    });

    // Fetch player emails from inscriptions when loading
    async function fetchPlayerEmails(tournoiId) {
      try {
        const response = await fetch(`${API_URL}/inscriptions/tournoi/${tournoiId}/inscriptions`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        if (response.ok) {
          const inscriptions = await response.json();
          inscriptions.forEach(i => {
            if (i.licence && i.email) {
              playerEmails[i.licence.replace(/\s/g, '')] = i.email;
            }
          });
        }
      } catch (error) {
        console.error('Error fetching player emails:', error);
      }
    }
  </script>
</body>
</html>
