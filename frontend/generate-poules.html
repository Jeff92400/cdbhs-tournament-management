<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>G√©n√©rer Poules - CDBHS</title>
  <link rel="icon" type="image/png" href="images/FrenchBillard-Icon-small.png">
  <link rel="stylesheet" href="css/styles.css">
  <script src="js/branding.js"></script>
  <style>
    .player-list {
      max-height: 400px;
      overflow-y: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    .player-item {
      display: flex;
      align-items: center;
      padding: 10px 15px;
      border-bottom: 1px solid #eee;
      cursor: pointer;
      transition: background 0.2s;
    }
    .player-item:hover {
      background: #f5f5f5;
    }
    .player-item.selected {
      background: #e3f2fd;
    }
    .player-item.new-player {
      background: #fff3e0;
    }
    .player-item.new-player.selected {
      background: #ffe0b2;
    }
    .player-item input[type="checkbox"] {
      margin-right: 15px;
      transform: scale(1.2);
    }
    .player-rank {
      width: 40px;
      font-weight: bold;
      color: #1F4788;
    }
    .player-name {
      flex: 1;
      font-weight: 500;
    }
    .player-club {
      color: #666;
      font-size: 0.9em;
      margin-left: 10px;
    }
    .player-licence {
      color: #999;
      font-size: 0.85em;
      margin-left: 10px;
    }
    .badge {
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 0.75em;
      margin-left: 10px;
    }
    .badge-new {
      background: #ff9800;
      color: white;
    }
    .badge-forfait {
      background: #dc3545;
      color: white;
    }
    .badge-inscrit {
      background: #28a745;
      color: white;
    }
    .poule-preview {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 15px;
      margin-top: 20px;
    }
    .poule-card {
      border: 2px solid #1F4788;
      border-radius: 8px;
      padding: 15px;
      background: white;
    }
    .poule-card h4 {
      margin: 0 0 10px 0;
      color: #1F4788;
      border-bottom: 1px solid #ddd;
      padding-bottom: 5px;
    }
    .poule-player {
      padding: 5px 0;
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .poule-player-rank {
      width: 25px;
      font-weight: bold;
      color: #666;
    }
    .move-player-btn {
      margin-left: auto;
      padding: 2px 8px;
      font-size: 0.75em;
      background: #6c757d;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      opacity: 0.7;
      transition: opacity 0.2s;
    }
    .move-player-btn:hover {
      opacity: 1;
    }
    .move-dropdown {
      position: absolute;
      background: white;
      border: 1px solid #ddd;
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      z-index: 100;
      min-width: 120px;
    }
    .move-dropdown-item {
      padding: 8px 12px;
      cursor: pointer;
      transition: background 0.2s;
    }
    .move-dropdown-item:hover {
      background: #f5f5f5;
    }
    .poule-card {
      position: relative;
    }
    .step-indicator {
      display: flex;
      justify-content: center;
      margin-bottom: 30px;
    }
    .step {
      display: flex;
      align-items: center;
      color: #999;
    }
    .step.active {
      color: #1F4788;
      font-weight: bold;
    }
    .step.completed {
      color: #28a745;
    }
    .step-number {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: #ddd;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-right: 8px;
      font-weight: bold;
    }
    .step.active .step-number {
      background: #1F4788;
      color: white;
    }
    .step.completed .step-number {
      background: #28a745;
      color: white;
    }
    .step-separator {
      width: 50px;
      height: 2px;
      background: #ddd;
      margin: 0 15px;
    }
    .summary-box {
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 8px;
      padding: 15px;
      margin: 15px 0;
    }
    .summary-row {
      display: flex;
      justify-content: space-between;
      padding: 5px 0;
    }
    .action-buttons {
      display: flex;
      gap: 10px;
      margin-top: 20px;
    }

    /* Upcoming tournament cards */
    .upcoming-tournament-card {
      border: 2px solid #dee2e6;
      border-radius: 12px;
      padding: 15px;
      background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .upcoming-tournament-card:hover {
      border-color: #1F4788;
      box-shadow: 0 4px 12px rgba(31, 71, 136, 0.15);
      transform: translateY(-2px);
    }
    .upcoming-tournament-card .tournament-mode {
      font-size: 0.85em;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 5px;
    }
    .upcoming-tournament-card .tournament-name {
      font-size: 1.1em;
      font-weight: bold;
      color: #1F4788;
      margin-bottom: 10px;
    }
    .upcoming-tournament-card .tournament-details {
      font-size: 0.9em;
      color: #666;
    }
    .upcoming-tournament-card .tournament-details span {
      display: block;
      margin-bottom: 3px;
    }
    .upcoming-tournament-card .tournament-date {
      color: #28a745;
      font-weight: 500;
    }
    .upcoming-tournament-card .tournament-inscrits {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid #eee;
      font-weight: 500;
      color: #17a2b8;
    }
    .upcoming-tournament-card .simulation-btn {
      margin-top: 10px;
      padding: 6px 12px;
      background: #17a2b8;
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 12px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      transition: background 0.2s;
    }
    .upcoming-tournament-card .simulation-btn:hover {
      background: #138496;
    }
    .upcoming-tournament-card .simulation-btn img {
      height: 14px;
      width: 14px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="navbar">
      <h2><img id="app-header-icon" src="images/FrenchBillard-Icon-small.png" alt="" style="height: 48px; width: 48px; vertical-align: middle; margin-right: 8px;" onerror="this.src='images/FrenchBillard-Icon-small.png';">Comp√©titions √† Jouer</h2>
      <div class="nav-links">
        <a href="dashboard.html">Accueil</a>
        <a href="rankings.html" class="nav-tooltip" data-tooltip="Classement par cat√©gorie de jeu au fur et √† mesure des tournois">Classements</a>
        <a href="generate-poules.html" class="active nav-tooltip" data-tooltip="Comp√©titions √† jouer / Convocations">Comp√©titions</a>
        <a href="calendar.html" class="nav-tooltip" data-tooltip="Calendrier de la saison">Calendrier</a>
        <a href="emailing.html" class="nav-tooltip" data-tooltip="Annonces, relances, r√©sultats, convocation">Com joueurs</a>
        <a href="settings.html" class="admin-only nav-tooltip" data-tooltip="R√©serv√© aux administrateurs">Param√®tres</a>
        <a href="#" id="logoutBtn" class="nav-logout">D√©connexion</a>
      </div>
    </div>

    <div id="errorMessage" class="error" style="display: none;"></div>
    <div id="successMessage" class="success" style="display: none;"></div>

    <!-- Warning: Update inscriptions -->
    <div class="card" id="inscriptionWarning" style="background: linear-gradient(135deg, #fff3cd 0%, #ffeeba 100%); border-left: 5px solid #ffc107; margin-bottom: 20px;">
      <div style="display: flex; align-items: flex-start; gap: 15px;">
        <div style="font-size: 32px;">‚ö†Ô∏è</div>
        <div style="flex: 1;">
          <h3 style="margin: 0 0 10px 0; color: #856404;">Mise √† jour des inscriptions</h3>
          <p style="margin: 0 0 10px 0; color: #856404;">
            Avant de g√©n√©rer les poules, assurez-vous que les fichiers CSV sont √† jour.
          </p>
          <div id="lastImportInfo" style="margin: 0 0 15px 0; padding: 10px 12px; background: rgba(255,255,255,0.5); border-radius: 4px;">
            <span style="color: #666;">Chargement des informations...</span>
          </div>
          <div style="display: flex; gap: 10px; flex-wrap: wrap;">
            <a href="import-external.html" class="btn" style="background: #ffc107; color: #856404; font-weight: bold;">
              üì§ Mettre √† jour les inscriptions
            </a>
            <button class="btn" id="skipInscriptionUpdate" style="background: #6c757d;">
              Continuer sans mise √† jour ‚Üí
            </button>
            <button class="btn" id="openForfaitManager" style="background: #dc3545; color: white; font-weight: bold;">
              üö´ Gestion des forfaits
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Upcoming Competitions Section (Tournaments + Finals) -->
    <div class="card" id="upcomingTournamentsCard" style="display: none;">
      <h3>üóìÔ∏è Comp√©titions √† venir</h3>
      <p style="color: #666; margin-bottom: 15px;">
        Cliquez sur un tournoi pour pr√©-remplir automatiquement la s√©lection.
      </p>
      <div id="upcomingTournamentsList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 15px;">
        <!-- Tournaments and Finals will be loaded here -->
      </div>
      <div id="noUpcomingTournaments" style="display: none; text-align: center; padding: 20px; color: #666;">
        <p>Aucune comp√©tition pr√©vue prochainement.</p>
      </div>
    </div>

    <!-- Step Indicator -->
    <div class="step-indicator" id="stepIndicatorContainer" style="display: none;">
      <div class="step active" id="step1Indicator">
        <span class="step-number">1</span>
        <span>S√©lection</span>
      </div>
      <div class="step-separator"></div>
      <div class="step" id="step2Indicator">
        <span class="step-number">2</span>
        <span>Joueurs</span>
      </div>
      <div class="step-separator"></div>
      <div class="step" id="step3Indicator">
        <span class="step-number">3</span>
        <span>Validation</span>
      </div>
      <div class="step-separator"></div>
      <div class="step" id="step4Indicator">
        <span class="step-number">4</span>
        <span>G√©n√©ration</span>
      </div>
    </div>

    <!-- Step 1: Select Tournament -->
    <div class="card" id="step1" style="display: none;">
      <h3>√âtape 1: S√©lectionner le Tournoi</h3>

      <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 15px; margin-bottom: 20px;">
        <div>
          <label for="modeSelect" style="display: block; margin-bottom: 5px; font-weight: 500;">Mode de jeu</label>
          <select id="modeSelect" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px;">
            <option value="">-- S√©lectionner --</option>
          </select>
        </div>
        <div>
          <label for="levelSelect" style="display: block; margin-bottom: 5px; font-weight: 500;">Classement FFB</label>
          <select id="levelSelect" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px;">
            <option value="">-- S√©lectionner --</option>
          </select>
          <!-- Hidden select to store the resolved category ID -->
          <select id="categorySelect" style="display: none;">
            <option value="">-- S√©lectionner --</option>
          </select>
        </div>
        <div>
          <label for="seasonSelect" style="display: block; margin-bottom: 5px; font-weight: 500;">Saison</label>
          <select id="seasonSelect" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px;">
            <option value="">-- S√©lectionner --</option>
          </select>
        </div>
        <div>
          <label for="tournamentSelect" style="display: block; margin-bottom: 5px; font-weight: 500;">Comp√©tition √† pr√©parer</label>
          <select id="tournamentSelect" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px;">
            <option value="">-- S√©lectionner --</option>
            <option value="1">Tournoi 1</option>
            <option value="2">Tournoi 2</option>
            <option value="3">Tournoi 3</option>
            <option value="Finale">üèÜ Finale D√©partementale</option>
          </select>
        </div>
      </div>

      <div id="tournamentInfo" style="display: none; margin-bottom: 20px; padding: 15px; background: #e3f2fd; border-radius: 8px; border-left: 4px solid #1F4788;">
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <div>
            <strong id="tournamentInfoName" style="color: #1F4788; font-size: 1.1em;">-</strong>
            <p style="margin: 5px 0 0 0; color: #666;">
              Date: <strong id="tournamentInfoDate">-</strong> |
              Lieu: <strong id="tournamentInfoLieu">-</strong> |
              Inscrits: <strong id="tournamentInfoInscrits">-</strong>
            </p>
          </div>
        </div>
      </div>

      <button class="btn" id="loadPlayersBtn" disabled>Charger les joueurs</button>
    </div>

    <!-- Step 2: Select Players -->
    <div class="card" id="step2" style="display: none;">
      <h3>√âtape 2: S√©lectionner les Joueurs</h3>

      <div class="summary-box">
        <div class="summary-row">
          <span>Joueurs s√©lectionn√©s:</span>
          <strong id="selectedCount">0</strong>
        </div>
        <div class="summary-row">
          <span>Configuration des poules:</span>
          <strong id="pouleConfig">-</strong>
        </div>
        <div class="summary-row">
          <span>Tables n√©cessaires:</span>
          <strong id="tablesNeeded">-</strong>
        </div>
      </div>

      <div style="margin-bottom: 15px; display: flex; gap: 10px;">
        <button class="btn" id="selectAllBtn">Tout s√©lectionner</button>
        <button class="btn" id="deselectAllBtn" style="background: #6c757d;">Tout d√©s√©lectionner</button>
        <button class="btn" id="selectRegisteredBtn" style="background: #17a2b8;">S√©lectionner les inscrits</button>
      </div>

      <h4 id="rankedPlayersTitle">Joueurs class√©s (du classement actuel)</h4>
      <div class="player-list" id="rankedPlayersList">
        <p style="padding: 20px; color: #666; text-align: center;">Chargement...</p>
      </div>

      <h4 style="margin-top: 20px;" id="newPlayersTitle">Nouveaux joueurs (inscrits non class√©s)</h4>
      <div class="player-list" id="newPlayersList">
        <p style="padding: 20px; color: #666; text-align: center;">Aucun nouveau joueur</p>
      </div>

      <h4 style="margin-top: 20px;">Ajout last minute</h4>
      <div style="background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 15px;">
        <p style="color: #666; font-size: 0.9em; margin-bottom: 10px;">Ajouter un joueur qui n'est pas inscrit dans le syst√®me externe</p>
        <div style="display: flex; gap: 10px; align-items: center;">
          <input type="text" id="lastMinuteSearch" placeholder="Rechercher par nom ou licence..."
                 style="flex: 1; padding: 10px; border: 1px solid #ddd; border-radius: 4px;">
          <button class="btn" id="addLastMinuteBtn" style="background: #dc3545;" disabled>Ajouter</button>
        </div>
        <div id="lastMinuteResults" style="display: none; max-height: 200px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; margin-top: 10px; background: white;"></div>
        <div class="player-list" id="lastMinutePlayersList" style="margin-top: 10px; max-height: 150px;"></div>
      </div>

      <div class="action-buttons">
        <button class="btn" id="backToStep1Btn" style="background: #6c757d;">Retour</button>
        <button class="btn" id="validatePlayersBtn" disabled>Valider la liste</button>
      </div>
    </div>

    <!-- Step 3: Validate & Preview -->
    <div class="card" id="step3" style="display: none;">
      <h3>√âtape 3: Validation et Aper√ßu</h3>

      <div class="summary-box">
        <div class="summary-row">
          <span>Cat√©gorie:</span>
          <strong id="summaryCategory">-</strong>
        </div>
        <div class="summary-row">
          <span>Tournoi:</span>
          <strong id="summaryTournament">-</strong>
        </div>
        <div class="summary-row">
          <span>Date:</span>
          <strong id="summaryDate">-</strong>
        </div>
        <div class="summary-row">
          <span>Lieu:</span>
          <strong id="summaryLieu">-</strong>
        </div>
        <div class="summary-row">
          <span>Nombre de joueurs:</span>
          <strong id="summaryPlayers">-</strong>
        </div>
        <div class="summary-row">
          <span>Configuration:</span>
          <strong id="summaryConfig">-</strong>
        </div>
        <div class="summary-row">
          <span>Tables n√©cessaires:</span>
          <strong id="summaryTables">-</strong>
        </div>
      </div>

      <!-- Game Parameters Section -->
      <div id="gameParamsSection" style="display: none; margin: 20px 0; padding: 15px; background: #e7f3ff; border-left: 4px solid #1F4788; border-radius: 4px;">
        <h4 style="margin: 0 0 15px 0; color: #1F4788;">Param√®tres de l'√©preuve</h4>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
          <div>
            <label style="display: block; font-weight: 500; margin-bottom: 5px;">Distance :</label>
            <select id="distanceSelect" style="width: 100%; padding: 10px; border: 1px solid #1F4788; border-radius: 4px; font-size: 14px;">
              <option value="normale">Distance Normale</option>
            </select>
          </div>
          <div>
            <span style="display: block; font-weight: 500; margin-bottom: 5px;">Coin :</span>
            <span id="gameParamCoin" style="display: inline-block; padding: 8px 15px; border-radius: 4px; background: #17a2b8; color: white; font-weight: bold;">-</span>
          </div>
          <div>
            <span style="display: block; font-weight: 500; margin-bottom: 5px;">Reprises max :</span>
            <span id="gameParamReprises" style="font-size: 18px; font-weight: bold; color: #1F4788;">-</span>
          </div>
        </div>
        <p id="gameParamMoyenne" style="margin: 15px 0 0 0; padding: 10px; background: #fff; border-radius: 4px; font-size: 13px; color: #666;">
          -
        </p>
      </div>

      <h4 id="poulePreviewTitle">Aper√ßu des Poules (Distribution Serpentine)</h4>
      <div class="poule-preview" id="poulePreview">
        <!-- Poules will be rendered here -->
      </div>

      <h4 style="margin-top: 30px;">Lieu et Horaire de la Comp√©tition</h4>
      <div class="summary-box">
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
          <div>
            <label style="display: block; margin-bottom: 5px; font-weight: 500;">Lieu principal</label>
            <select id="locationSelect1" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px;">
              <option value="">-- S√©lectionner un club --</option>
            </select>
          </div>
          <div>
            <label style="display: block; margin-bottom: 5px; font-weight: 500;">Heure de d√©but</label>
            <select id="startTime1" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px;">
              <option value="">-- S√©lectionner --</option>
              <option value="08:00">08:00</option>
              <option value="08:30">08:30</option>
              <option value="09:00">09:00</option>
              <option value="09:30">09:30</option>
              <option value="10:00">10:00</option>
              <option value="10:30">10:30</option>
              <option value="11:00">11:00</option>
              <option value="11:30">11:30</option>
              <option value="12:00">12:00</option>
              <option value="12:30">12:30</option>
              <option value="13:00">13:00</option>
              <option value="13:30" selected>13:30</option>
              <option value="14:00">14:00</option>
              <option value="14:30">14:30</option>
              <option value="15:00">15:00</option>
              <option value="15:30">15:30</option>
              <option value="16:00">16:00</option>
              <option value="16:30">16:30</option>
              <option value="17:00">17:00</option>
              <option value="17:30">17:30</option>
              <option value="18:00">18:00</option>
            </select>
          </div>
        </div>

        <div id="location2Container" style="display: none; margin-top: 15px; padding-top: 15px; border-top: 1px dashed #ddd;">
          <div style="display: grid; grid-template-columns: 1fr 1fr auto; gap: 20px; align-items: end;">
            <div>
              <label style="display: block; margin-bottom: 5px; font-weight: 500;">Lieu secondaire (split)</label>
              <select id="locationSelect2" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px;">
                <option value="">-- S√©lectionner un club --</option>
              </select>
            </div>
            <div>
              <label style="display: block; margin-bottom: 5px; font-weight: 500;">Heure de d√©but</label>
              <select id="startTime2" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px;">
                <option value="">-- S√©lectionner --</option>
                <option value="08:00">08:00</option>
                <option value="08:30">08:30</option>
                <option value="09:00">09:00</option>
                <option value="09:30">09:30</option>
                <option value="10:00">10:00</option>
                <option value="10:30">10:30</option>
                <option value="11:00">11:00</option>
                <option value="11:30">11:30</option>
                <option value="12:00">12:00</option>
                <option value="12:30">12:30</option>
                <option value="13:00">13:00</option>
                <option value="13:30">13:30</option>
                <option value="14:00" selected>14:00</option>
                <option value="14:30">14:30</option>
                <option value="15:00">15:00</option>
                <option value="15:30">15:30</option>
                <option value="16:00">16:00</option>
                <option value="16:30">16:30</option>
                <option value="17:00">17:00</option>
                <option value="17:30">17:30</option>
                <option value="18:00">18:00</option>
              </select>
            </div>
            <button class="btn" id="removeLocation2Btn" style="background: #dc3545; padding: 10px 15px;">Retirer</button>
          </div>
        </div>

        <div style="margin-top: 15px;">
          <button class="btn" id="addLocation2Btn" style="background: #17a2b8;">+ Ajouter un second lieu (split)</button>
        </div>
      </div>

      <div class="action-buttons" style="flex-wrap: wrap; gap: 10px;">
        <button class="btn" id="backToStep2Btn" style="background: #6c757d;">Modifier la liste</button>
        <button class="btn btn-success" id="generateExcelBtn" style="background: #28a745;">G√©n√©rer le fichier Excel</button>
        <button class="btn" id="generateSummaryPdfBtn" style="background: #dc3545; color: white;">G√©n√©rer PDF R√©capitulatif</button>
        <button class="btn" id="goToEmailBtn" style="background: #17a2b8; color: white;">Envoyer les convocations</button>
      </div>
    </div>

    <!-- Step 4: Download -->
    <div class="card" id="step4" style="display: none;">
      <h3>√âtape 4: T√©l√©chargement</h3>
      <div style="text-align: center; padding: 40px;">
        <div style="font-size: 48px; margin-bottom: 20px;">‚úÖ</div>
        <h4>Fichier g√©n√©r√© avec succ√®s !</h4>
        <p style="color: #666; margin-bottom: 20px;">Le fichier Excel a √©t√© t√©l√©charg√© automatiquement.</p>

        <!-- Email convocations section -->
        <div id="emailSection" style="margin: 30px 0; padding: 20px; background: #f8f9fa; border-radius: 8px; border: 1px solid #dee2e6;">
          <h4 style="margin: 0 0 15px 0; color: #1F4788;">üìß Envoyer les convocations par email</h4>
          <p style="color: #666; margin-bottom: 15px;">
            Envoyer une convocation personnalis√©e √† chaque joueur avec le d√©tail de sa poule.
          </p>
          <div id="emailStats" style="margin-bottom: 15px; padding: 10px; background: white; border-radius: 4px;">
            <span id="emailableCount">-</span> joueurs avec email valide sur <span id="totalPlayersCount">-</span>
          </div>

          <!-- Player selection list -->
          <div id="playerSelectionSection" style="margin-bottom: 15px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
              <label style="font-weight: bold; color: #333;">S√©lectionner les joueurs √† convoquer :</label>
              <div>
                <button type="button" id="emailSelectAllBtn" class="btn" style="background: #28a745; padding: 5px 10px; font-size: 12px; margin-right: 5px;">Tout cocher</button>
                <button type="button" id="emailDeselectAllBtn" class="btn" style="background: #dc3545; padding: 5px 10px; font-size: 12px;">Tout d√©cocher</button>
              </div>
            </div>
            <div id="playerCheckboxList" style="max-height: 300px; overflow-y: auto; background: white; border: 1px solid #ddd; border-radius: 4px; padding: 10px;">
              <!-- Player checkboxes will be inserted here -->
            </div>
            <div id="selectedCount" style="margin-top: 10px; font-size: 14px; color: #666;">
              <strong><span id="checkedCount">0</span></strong> joueur(s) s√©lectionn√©(s) pour l'envoi
              <br><span style="color: #17a2b8;">üìã R√©capitulatif envoy√© √† : <strong id="summaryEmailDisplay">cdbhs92@gmail.com</strong></span>
            </div>
          </div>

          <!-- Special note field -->
          <div style="margin-bottom: 15px;">
            <label style="display: block; font-weight: bold; color: #333; margin-bottom: 8px;">
              Note particuli√®re √† inscrire sur l'email d'envoi :
            </label>
            <textarea id="specialNoteField"
                      placeholder="Exemple: Attention, le tournoi d√©butera exceptionnellement √† 13H00 ce samedi..."
                      style="width: 100%; min-height: 80px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-family: inherit; font-size: 14px; resize: vertical;"></textarea>
            <p style="margin: 5px 0 0 0; font-size: 12px; color: #666;">
              Cette note appara√Ætra en √©vidence en haut de l'email, avant le message de convocation.
            </p>
          </div>

          <!-- Test mode section -->
          <div id="testModeSection" style="margin-bottom: 20px; padding: 15px; background: #fff8e1; border: 2px solid #ffc107; border-radius: 8px;">
            <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; font-weight: bold; color: #333;">
              <input type="checkbox" id="testModeCheckbox" style="width: 18px; height: 18px;">
              <span>Mode Test</span>
              <span style="font-weight: normal; color: #666;"> - Envoyer uniquement √† mon adresse</span>
            </label>
            <div id="testEmailContainer" style="display: none; margin-top: 10px;">
              <input type="email" id="testEmailInput"
                     placeholder="votre.email@exemple.com"
                     style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
            </div>
          </div>

          <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
            <button class="btn" id="sendConvocationsBtn" style="background: #17a2b8;">
              ‚úâÔ∏è Envoyer les convocations
            </button>
            <button class="btn" id="sendTestBtn" style="background: #f59e0b; display: none;">
              üß™ Envoyer le Test
            </button>
            <button class="btn" id="savePoulesOnlyBtn" style="background: #6c757d;">
              üíæ Sauvegarder les poules (sans email)
            </button>
          </div>
          <div id="savePoulesResult" style="display: none; margin-top: 10px; padding: 10px; border-radius: 4px;"></div>
          <div id="emailProgress" style="display: none; margin-top: 15px;">
            <div style="background: #e9ecef; border-radius: 4px; overflow: hidden;">
              <div id="emailProgressBar" style="height: 8px; background: #17a2b8; width: 0%; transition: width 0.3s;"></div>
            </div>
            <p id="emailProgressText" style="color: #666; margin-top: 10px;"></p>
          </div>
          <div id="emailResults" style="display: none; margin-top: 15px; text-align: left;"></div>
        </div>

        <div class="action-buttons" style="justify-content: center;">
          <button class="btn" id="backToStep3Btn" style="background: #6c757d;">Retour √† l'aper√ßu</button>
          <button class="btn" id="newGenerationBtn">Nouvelle g√©n√©ration</button>
        </div>
      </div>
    </div>
  </div>

  <script src="js/auth-utils.js"></script>
  <script src="js/app-branding.js"></script>
  <script>
    const API_URL = '/api';

    // Check authentication
    if (!requireAuth()) {
      throw new Error('Not authenticated'); // Stop script execution
    }
    const token = localStorage.getItem('token');

    // Check user role and show/hide admin elements
    const userRole = localStorage.getItem('userRole');
    if (userRole === 'admin') {
      document.querySelectorAll('.admin-only').forEach(el => el.style.display = '');
    } else {
      document.querySelectorAll('.admin-only').forEach(el => el.style.display = 'none');
    }

    // Load summary email setting for display
    (async function loadSummaryEmailDisplay() {
      try {
        const response = await fetch(`${API_URL}/settings/app/summary_email`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        if (response.ok) {
          const data = await response.json();
          const email = data.value || 'cdbhs92@gmail.com';
          document.getElementById('summaryEmailDisplay').textContent = email;
        }
      } catch (error) {
        console.error('Error loading summary email:', error);
      }
    })();

    // Logout
    document.getElementById('logoutBtn').addEventListener('click', (e) => {
      e.preventDefault();
      localStorage.removeItem('token');
      localStorage.removeItem('userRole');
      localStorage.removeItem('username');
      window.location.href = 'login.html';
    });

    // Skip inscription update warning
    document.getElementById('skipInscriptionUpdate').addEventListener('click', () => {
      document.getElementById('inscriptionWarning').style.display = 'none';
      document.getElementById('stepIndicatorContainer').style.display = 'flex';
      document.getElementById('step1').style.display = 'block';
      // Show and load upcoming tournaments
      document.getElementById('upcomingTournamentsCard').style.display = 'block';
      loadUpcomingTournaments();
    });

    // Format import age with color coding
    function formatImportAge(importDate) {
      if (!importDate) {
        return { text: 'Jamais import√©', color: '#dc3545', isOld: true };
      }

      const lastDate = new Date(importDate);
      const now = new Date();
      const diffMs = now - lastDate;
      const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
      const diffHours = Math.floor(diffMs / (1000 * 60 * 60));

      let ageText = '';
      let ageColor = '#28a745'; // green
      let isOld = false;

      if (diffDays > 7) {
        ageText = `il y a ${diffDays} jours`;
        ageColor = '#dc3545'; // red - very old
        isOld = true;
      } else if (diffDays > 2) {
        ageText = `il y a ${diffDays} jours`;
        ageColor = '#fd7e14'; // orange - old
        isOld = true;
      } else if (diffDays > 0) {
        ageText = `il y a ${diffDays} jour${diffDays > 1 ? 's' : ''}`;
        ageColor = '#ffc107'; // yellow - recent
      } else if (diffHours > 0) {
        ageText = `il y a ${diffHours} heure${diffHours > 1 ? 's' : ''}`;
        ageColor = '#28a745'; // green - very recent
      } else {
        ageText = "√† l'instant";
        ageColor = '#28a745'; // green
      }

      return { text: ageText, color: ageColor, isOld };
    }

    // Get season for a given date (Sept-Aug cycle)
    function getSeasonForDate(date) {
      const year = date.getFullYear();
      const month = date.getMonth(); // 0-11
      if (month >= 8) {
        return `${year}-${year + 1}`;
      } else {
        return `${year - 1}-${year}`;
      }
    }

    // Load and display last import dates for all file types
    async function loadLastImportDate() {
      try {
        const response = await fetch(`${API_URL}/inscriptions/last-import`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });

        const infoElement = document.getElementById('lastImportInfo');

        if (response.ok) {
          const data = await response.json();

          // Get current season
          const currentSeason = getSeasonForDate(new Date());

          // Fetch tournois and inscriptions to calculate season-specific counts
          let seasonTournoiCount = 0;
          let seasonInscriptionCount = 0;
          let tournoiMap = {};

          try {
            const tournoiRes = await fetch(`${API_URL}/inscriptions/tournoi`, {
              headers: { 'Authorization': `Bearer ${token}` }
            });
            if (tournoiRes.ok) {
              const tournois = await tournoiRes.json();
              tournois.forEach(t => { tournoiMap[t.tournoi_id] = t; });
              seasonTournoiCount = tournois.filter(t => {
                if (!t.debut) return false;
                return getSeasonForDate(new Date(t.debut)) === currentSeason;
              }).length;
            }

            const inscRes = await fetch(`${API_URL}/inscriptions`, {
              headers: { 'Authorization': `Bearer ${token}` }
            });
            if (inscRes.ok) {
              const inscriptions = await inscRes.json();
              seasonInscriptionCount = inscriptions.filter(i => {
                const tournoi = tournoiMap[i.tournoi_id];
                if (!tournoi || !tournoi.debut) return false;
                return getSeasonForDate(new Date(tournoi.debut)) === currentSeason;
              }).length;
            }
          } catch (e) {
            console.error('Error fetching season counts:', e);
          }

          const fileTypes = [
            { key: 'inscriptions', label: 'Inscriptions', icon: 'üìù', seasonCount: seasonInscriptionCount },
            { key: 'tournois', label: 'Tournois', icon: 'üèÜ', seasonCount: seasonTournoiCount },
            { key: 'joueurs', label: 'Joueurs', icon: 'üë•', seasonCount: null }
          ];

          let html = `<div style="display: grid; gap: 8px;">`;
          html += `<div style="font-size: 11px; color: #856404; margin-bottom: 5px;">Saison ${currentSeason}</div>`;

          fileTypes.forEach(ft => {
            const info = data[ft.key];
            const age = formatImportAge(info?.importDate);
            const countDisplay = ft.seasonCount !== null ? ft.seasonCount : (info?.recordCount || 0);

            html += `
              <div style="display: flex; align-items: center; gap: 10px;">
                <span style="width: 24px;">${ft.icon}</span>
                <span style="min-width: 100px; color: #856404; font-weight: 500;">${ft.label}:</span>
                <span style="color: ${age.color}; font-weight: ${age.isOld ? 'bold' : 'normal'};">
                  ${age.text}
                  <span style="color: #666; font-weight: normal;"> (${countDisplay} enregistrements)</span>
                </span>
              </div>
            `;
          });

          html += '</div>';
          infoElement.innerHTML = html;
        } else {
          infoElement.innerHTML = `<span style="color: #666;">Impossible de charger les informations</span>`;
        }
      } catch (error) {
        console.error('Error loading last import date:', error);
        document.getElementById('lastImportInfo').innerHTML = `<span style="color: #666;">Erreur de chargement</span>`;
      }
    }

    // Load last import date on page load
    loadLastImportDate();

    // State
    let categories = [];
    let rankedPlayers = [];
    let newPlayers = [];
    let lastMinutePlayers = [];
    let allSystemPlayers = [];
    let selectedPlayers = [];
    let currentCategory = null;
    let currentSeason = null;
    let currentTournament = null;
    let externalTournois = [];
    let matchingTournoi = null;
    let selectedLastMinutePlayer = null;
    let clubs = [];
    let currentGameParams = null;
    let isFinale = false;

    // Poule configuration based on number of players
    const POULE_CONFIG = {
      3: { poules: [3], tables: 1 },
      4: { poules: [4], tables: 2 },
      5: { poules: [5], tables: 2 },
      6: { poules: [3, 3], tables: 2 },
      7: { poules: [3, 4], tables: 3 },
      8: { poules: [3, 5], tables: 3 },
      9: { poules: [3, 3, 3], tables: 3 },
      10: { poules: [3, 3, 4], tables: 4 },
      11: { poules: [3, 3, 5], tables: 4 },
      12: { poules: [3, 3, 3, 3], tables: 4 },
      13: { poules: [3, 3, 3, 4], tables: 5 },
      14: { poules: [3, 3, 3, 5], tables: 5 },
      15: { poules: [3, 3, 3, 3, 3], tables: 5 },
      16: { poules: [3, 3, 3, 3, 4], tables: 6 },
      17: { poules: [3, 3, 3, 3, 5], tables: 6 },
      18: { poules: [3, 3, 3, 3, 3, 3], tables: 6 },
      19: { poules: [3, 3, 3, 3, 3, 4], tables: 7 },
      20: { poules: [3, 3, 3, 3, 3, 5], tables: 7 }
    };

    // Get poule configuration for a given number of players
    function getPouleConfig(numPlayers) {
      if (numPlayers < 3) {
        return { poules: [], tables: 0, description: 'Pas assez de joueurs' };
      }
      if (numPlayers > 20) {
        // Extend pattern for more than 20 players
        const base = Math.floor(numPlayers / 3);
        const remainder = numPlayers % 3;
        const poules = Array(base).fill(3);
        if (remainder === 1) {
          poules[poules.length - 1] = 4;
        } else if (remainder === 2) {
          poules[poules.length - 1] = 5;
        }
        return {
          poules,
          tables: poules.length + 1,
          description: formatPouleDescription(poules)
        };
      }
      const config = POULE_CONFIG[numPlayers];
      return { ...config, description: formatPouleDescription(config.poules) };
    }

    // Format poule description: "5 poules de 3 et 1 poule de 4 (6 poules)"
    function formatPouleDescription(poules) {
      if (poules.length === 0) return '-';
      if (poules.length === 1) return `1 poule de ${poules[0]}`;

      // Count poules by size
      const counts = {};
      poules.forEach(size => {
        counts[size] = (counts[size] || 0) + 1;
      });

      // Build description parts
      const parts = [];
      const sizes = Object.keys(counts).sort((a, b) => a - b);
      sizes.forEach(size => {
        const count = counts[size];
        parts.push(`${count} poule${count > 1 ? 's' : ''} de ${size}`);
      });

      return `${parts.join(' et ')} (${poules.length} poules)`;
    }

    // Serpentine distribution
    function distributeSerpentine(players, pouleSizes) {
      const numPoules = pouleSizes.length;
      const poules = pouleSizes.map((size, i) => ({
        number: i + 1,
        size,
        players: []
      }));

      let playerIndex = 0;
      let round = 0;

      while (playerIndex < players.length) {
        const isLeftToRight = round % 2 === 0;

        for (let i = 0; i < numPoules && playerIndex < players.length; i++) {
          const pouleIndex = isLeftToRight ? i : (numPoules - 1 - i);
          const poule = poules[pouleIndex];

          if (poule.players.length < poule.size) {
            poules[pouleIndex].players.push({
              ...players[playerIndex],
              originalRank: playerIndex + 1
            });
            playerIndex++;
          }
        }
        round++;
      }

      return poules;
    }

    // Load categories
    async function loadCategories() {
      try {
        // Fetch both tournaments and all categories in parallel
        const [tournamentsResponse, categoriesResponse] = await Promise.all([
          fetch(`${API_URL}/tournaments`, {
            headers: { 'Authorization': `Bearer ${token}` }
          }),
          fetch(`${API_URL}/tournaments/categories`, {
            headers: { 'Authorization': `Bearer ${token}` }
          })
        ]);

        // Build category map starting with all categories from the categories table
        const categoryMap = new Map();

        // First, add all categories from the categories table (ensures all are available)
        if (categoriesResponse.ok) {
          const allCategories = await categoriesResponse.json();
          if (Array.isArray(allCategories)) {
            allCategories.forEach(c => {
              const key = `${c.game_type}-${c.level}`;
              categoryMap.set(key, {
                id: c.id,
                game_type: c.game_type,
                level: c.level,
                display_name: c.display_name
              });
            });
          }
        }

        // Then add/update from existing tournaments (to get category_id mapping if different)
        if (tournamentsResponse.ok) {
          const tournaments = await tournamentsResponse.json();
          if (Array.isArray(tournaments)) {
            tournaments.forEach(t => {
              const key = `${t.game_type}-${t.level}`;
              if (!categoryMap.has(key)) {
                categoryMap.set(key, {
                  id: t.category_id,
                  game_type: t.game_type,
                  level: t.level,
                  display_name: t.display_name
                });
              }
            });

            // Extract unique seasons
            const seasons = [...new Set(tournaments.map(t => t.season))].sort().reverse();
            const seasonSelect = document.getElementById('seasonSelect');
            seasonSelect.innerHTML = '<option value="">-- S√©lectionner --</option>';
            seasons.forEach(season => {
              seasonSelect.innerHTML += `<option value="${season}">${season}</option>`;
            });

            // Pre-select current season if available
            if (seasons.length > 0) {
              seasonSelect.value = seasons[0];
              currentSeason = seasons[0];
            }
          }
        }

        // Assign to global categories array
        categories = Array.from(categoryMap.values());

        // Populate mode selector with unique game types
        const modes = [...new Set(categories.map(c => c.game_type))].sort();
        const modeSelect = document.getElementById('modeSelect');
        modeSelect.innerHTML = '<option value="">-- S√©lectionner --</option>';
        modes.forEach(mode => {
          modeSelect.innerHTML += `<option value="${mode}">${mode}</option>`;
        });

        // Keep hidden categorySelect for compatibility
        const select = document.getElementById('categorySelect');
        select.innerHTML = '<option value="">-- S√©lectionner --</option>';
        categories.forEach(cat => {
          select.innerHTML += `<option value="${cat.id}">${cat.display_name}</option>`;
        });
      } catch (error) {
        console.error('Error loading categories:', error);
      }
    }

    loadCategories();

    // Load upcoming competitions (tournaments + finals)
    async function loadUpcomingTournaments() {
      const container = document.getElementById('upcomingTournamentsList');
      const noTournamentsDiv = document.getElementById('noUpcomingTournaments');
      const card = document.getElementById('upcomingTournamentsCard');

      // Show loading state
      container.innerHTML = '<p style="text-align: center; color: #666;">Chargement des comp√©titions...</p>';
      container.style.display = 'block';
      noTournamentsDiv.style.display = 'none';

      try {
        // Fetch both tournaments and finals
        const [tournamentsRes, finalesRes] = await Promise.all([
          fetch(`${API_URL}/inscriptions/tournoi/upcoming`, {
            headers: { 'Authorization': `Bearer ${token}` }
          }),
          fetch(`${API_URL}/inscriptions/finales/upcoming`, {
            headers: { 'Authorization': `Bearer ${token}` }
          }).catch(() => ({ ok: false })) // Handle if endpoint doesn't exist yet
        ]);

        let allCompetitions = [];

        if (tournamentsRes.ok) {
          const tournaments = await tournamentsRes.json();
          tournaments.forEach(t => {
            t.isFinale = false;
          });
          allCompetitions = allCompetitions.concat(tournaments);
        }

        if (finalesRes.ok) {
          const finales = await finalesRes.json();
          const now = new Date();
          finales.forEach(f => {
            f.isFinale = true;
            // Check if T3 of the same category has occurred
            const t3 = allCompetitions.find(t =>
              t.mode?.toUpperCase() === f.mode?.toUpperCase() &&
              t.categorie?.toUpperCase() === f.categorie?.toUpperCase() &&
              (t.nom?.toUpperCase().includes('T3') || t.nom?.toUpperCase().includes('TOURNOI 3'))
            );
            if (t3 && t3.debut) {
              const t3Date = new Date(t3.debut);
              f.t3Pending = t3Date > now;
              f.t3Date = t3.debut;
              f.daysUntilT3 = Math.ceil((t3Date - now) / (1000 * 60 * 60 * 24));
            } else {
              f.t3Pending = false;
            }
          });
          allCompetitions = allCompetitions.concat(finales);
        }

        // Sort by date
        allCompetitions.sort((a, b) => {
          const dateA = a.debut ? new Date(a.debut) : new Date('9999-12-31');
          const dateB = b.debut ? new Date(b.debut) : new Date('9999-12-31');
          return dateA - dateB;
        });

        if (allCompetitions.length === 0) {
          container.style.display = 'none';
          noTournamentsDiv.style.display = 'block';
        } else {
          container.style.display = 'grid';
          noTournamentsDiv.style.display = 'none';

          container.innerHTML = allCompetitions.map(t => {
            const dateStr = t.debut
              ? new Date(t.debut).toLocaleDateString('fr-FR', { weekday: 'long', day: 'numeric', month: 'long' })
              : 'Date non d√©finie';

            // Extract tournament number from name (e.g., "TOURNOI 2" -> "2") or "Finale" for finals
            const tournamentMatch = t.nom.match(/TOURNOI\s*(\d+)/i);
            const tournamentNum = tournamentMatch ? tournamentMatch[1] : (t.isFinale ? 'Finale' : '');

            const cardStyle = t.isFinale
              ? 'border: 2px solid #ffc107; background: linear-gradient(135deg, #fffde7 0%, #fff8e1 100%);'
              : '';
            const badgeHtml = t.isFinale
              ? '<span style="background: #ffc107; color: #333; padding: 2px 8px; border-radius: 10px; font-size: 10px; font-weight: bold; margin-left: 8px;">üèÜ FINALE</span>'
              : '';
            const t3PendingBadge = t.t3Pending
              ? `<div style="background: #fff3cd; border: 1px solid #ffc107; color: #856404; padding: 4px 8px; border-radius: 6px; font-size: 11px; margin-top: 6px;">‚è≥ T3 en attente (${t.daysUntilT3}j)</div>`
              : '';

            // Check if simulation should be available (> 7 days away and >= 3 inscriptions)
            const tournamentDate = t.debut ? new Date(t.debut) : null;
            const daysUntil = tournamentDate ? Math.ceil((tournamentDate - new Date()) / (1000 * 60 * 60 * 24)) : 0;
            const inscritCount = t.isFinale ? (t.inscribed_finalist_count || 0) : (t.inscrit_count || 0);
            const showSimulation = daysUntil >= 7 && inscritCount >= 3;

            return `
              <div class="upcoming-tournament-card"
                   style="${cardStyle}"
                   data-mode="${t.mode}"
                   data-categorie="${t.categorie}"
                   data-tournament-num="${tournamentNum}"
                   data-tournoi-id="${t.tournoi_id}"
                   data-lieu="${t.lieu || ''}"
                   data-date="${t.debut || ''}"
                   data-is-finale="${t.isFinale}"
                   data-finalist-count="${t.finalist_count || 0}"
                   data-inscribed-finalist-count="${t.inscribed_finalist_count || 0}">
                <div class="tournament-mode">${t.mode} - ${t.categorie}${badgeHtml}</div>
                <div class="tournament-name">${t.isFinale ? 'Finale D√©partementale' : t.nom}</div>
                <div class="tournament-details">
                  <span class="tournament-date">üìÖ ${dateStr}</span>
                  <span>üìç ${t.lieu || 'Lieu non d√©fini'}</span>
                </div>
                <div class="tournament-inscrits">
                  üë• ${t.isFinale ? `${t.inscribed_finalist_count || 0}/${t.finalist_count || 0} inscrits` : `${t.inscrit_count || 0} inscrit(s)`}
                </div>
                ${t3PendingBadge}
                ${showSimulation ? `
                  <button class="simulation-btn" data-tournoi-id="${t.tournoi_id}" onclick="event.stopPropagation(); openSimulationModal(${t.tournoi_id});">
                    <img src="images/french-billiard.png" alt=""> Simulation des poules
                  </button>
                ` : ''}
              </div>
            `;
          }).join('');

          // Add click handlers
          container.querySelectorAll('.upcoming-tournament-card').forEach(card => {
            card.addEventListener('click', () => selectUpcomingTournament(card));
          });
        }

        card.style.display = 'block';
      } catch (error) {
        console.error('Error loading upcoming competitions:', error);
      }
    }

    // Handle click on upcoming tournament card
    async function selectUpcomingTournament(card) {
      const mode = card.dataset.mode;
      const categorie = card.dataset.categorie;
      const tournamentNum = card.dataset.tournamentNum;
      const tournoiId = card.dataset.tournoiId;
      const lieu = card.dataset.lieu;
      const date = card.dataset.date;
      isFinale = card.dataset.isFinale === 'true';

      // Find matching category using mode_mapping logic
      // We need to match the IONOS mode to our internal game_type
      const modeNormalized = mode.toUpperCase().replace(/\s+/g, '');

      // Mapping from IONOS modes to internal game_types
      const modeToGameType = {
        'LIBRE': 'LIBRE',
        '3BANDES': '3BANDES',
        '3 BANDES': '3BANDES',
        'BANDE': 'BANDE',
        '1BANDE': 'BANDE',
        '1 BANDE': 'BANDE',
        'CADRE': 'CADRE'
      };

      // Mapping from IONOS levels to internal levels
      const levelMapping = {
        'N1': 'NATIONALE 1',
        'N2': 'NATIONALE 2',
        'N3': 'NATIONALE 3',
        'R1': 'REGIONALE 1',
        'R2': 'REGIONALE 2',
        'R3': 'REGIONALE 3',
        'D1': 'DEPARTEMENTALE 1',
        'D2': 'DEPARTEMENTALE 2',
        'D3': 'DEPARTEMENTALE 3'
      };

      const gameType = modeToGameType[mode.toUpperCase()] || modeToGameType[modeNormalized] || mode.toUpperCase();
      const normalizedLevel = levelMapping[categorie.toUpperCase()] || categorie.toUpperCase();

      // Normalize for comparison: remove spaces and convert to uppercase
      const normalizeForCompare = (str) => str.toUpperCase().replace(/\s+/g, '');

      // Find matching category (flexible matching: ignore spaces, handle level variations)
      const matchingCategory = categories.find(c => {
        const cGameType = normalizeForCompare(c.game_type);
        const cLevel = c.level.toUpperCase();
        const targetGameType = normalizeForCompare(gameType);

        const gameTypeMatch = cGameType === targetGameType;
        const levelMatch = cLevel === normalizedLevel ||
               cLevel === categorie.toUpperCase() ||
               cLevel.startsWith(normalizedLevel) ||
               cLevel.startsWith(categorie.toUpperCase()) ||
               normalizedLevel.startsWith(cLevel) ||
               categorie.toUpperCase() === cLevel.replace(/\s+/g, '').substring(0, categorie.length);

        return gameTypeMatch && levelMatch;
      });

      if (matchingCategory) {
        // Set mode and level dropdowns
        document.getElementById('modeSelect').value = matchingCategory.game_type;
        document.getElementById('modeSelect').dispatchEvent(new Event('change'));
        document.getElementById('levelSelect').value = matchingCategory.level;
        document.getElementById('levelSelect').dispatchEvent(new Event('change'));
        // For finals, set tournament to "Finale", otherwise use tournament number
        document.getElementById('tournamentSelect').value = isFinale ? 'Finale' : tournamentNum;

        // Store the selected tournament info for later use (including finalist counts from card data)
        window.selectedUpcomingTournament = {
          tournoiId,
          lieu,
          date,
          mode,
          categorie,
          tournamentNum: isFinale ? 'Finale' : tournamentNum,
          isFinale,
          finalist_count: parseInt(card.dataset.finalistCount) || 0,
          inscribed_finalist_count: parseInt(card.dataset.inscribedFinalistCount) || 0
        };

        // Trigger change event to load tournament info
        document.getElementById('categorySelect').dispatchEvent(new Event('change'));

        // Enable load button
        document.getElementById('loadPlayersBtn').disabled = false;

        // Scroll to step 1
        document.getElementById('step1').scrollIntoView({ behavior: 'smooth', block: 'start' });
      } else {
        alert(`Impossible de trouver la cat√©gorie correspondante pour ${mode} - ${categorie}`);
      }
    }

    // Also load upcoming tournaments when coming from import-external page
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('skipWarning') === 'true') {
      document.getElementById('inscriptionWarning').style.display = 'none';
      document.getElementById('stepIndicatorContainer').style.display = 'flex';
      document.getElementById('step1').style.display = 'block';
      document.getElementById('upcomingTournamentsCard').style.display = 'block';
      loadUpcomingTournaments();
    }

    // Pending location to preselect (stored when preselectLocation is called before clubs load)
    let pendingLocationToPreselect = null;

    // Load clubs for location selection
    async function loadClubs() {
      try {
        const response = await fetch(`${API_URL}/clubs`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        if (response.ok) {
          clubs = await response.json();
          populateLocationDropdowns();
          // Apply pending preselection if any
          if (pendingLocationToPreselect) {
            preselectLocation(pendingLocationToPreselect);
            pendingLocationToPreselect = null;
          }
        }
      } catch (error) {
        console.error('Error loading clubs:', error);
      }
    }

    function populateLocationDropdowns() {
      const select1 = document.getElementById('locationSelect1');
      const select2 = document.getElementById('locationSelect2');

      const options = '<option value="">-- S√©lectionner un club --</option>' +
        clubs.map(c => {
          const fullAddress = [c.street, c.zip_code, c.city].filter(Boolean).join(' ');
          return `<option value="${c.id}"
            data-name="${c.name}"
            data-street="${c.street || ''}"
            data-city="${c.city || ''}"
            data-zipcode="${c.zip_code || ''}"
            data-phone="${c.phone || ''}"
            data-email="${c.email || ''}"
            data-address="${fullAddress}">${c.name}</option>`;
        }).join('');

      select1.innerHTML = options;
      select2.innerHTML = options;
    }

    // Normalize string: remove accents and convert to lowercase
    function normalizeString(str) {
      return (str || '').toLowerCase().trim()
        .normalize('NFD').replace(/[\u0300-\u036f]/g, ''); // Remove accents
    }

    function preselectLocation(locationName) {
      console.log('[preselectLocation] Called with:', locationName, 'clubs loaded:', clubs.length);
      if (!locationName) return;

      // If clubs not loaded yet, store for later
      if (clubs.length === 0) {
        console.log('[preselectLocation] Clubs not loaded, storing for later');
        pendingLocationToPreselect = locationName;
        return;
      }

      const select1 = document.getElementById('locationSelect1');
      const locationNorm = normalizeString(locationName);

      // Try to find matching club by name, display_name, or city
      for (const club of clubs) {
        const clubNameNorm = normalizeString(club.name);
        const clubDisplayNorm = normalizeString(club.display_name);
        const clubCityNorm = normalizeString(club.city);

        // Check name match (accent-insensitive)
        if (clubNameNorm.includes(locationNorm) || locationNorm.includes(clubNameNorm)) {
          console.log('[preselectLocation] Found match by name:', club.name, '-> id:', club.id);
          select1.value = club.id;
          updatePouleLocationLabels();
          return;
        }

        // Check display_name match (accent-insensitive)
        if (clubDisplayNorm && (clubDisplayNorm.includes(locationNorm) || locationNorm.includes(clubDisplayNorm))) {
          console.log('[preselectLocation] Found match by display_name:', club.display_name, '-> id:', club.id);
          select1.value = club.id;
          updatePouleLocationLabels();
          return;
        }

        // Check city match (accent-insensitive)
        if (clubCityNorm && (clubCityNorm === locationNorm || clubCityNorm.includes(locationNorm) || locationNorm.includes(clubCityNorm))) {
          console.log('[preselectLocation] Found match by city:', club.name, 'city:', club.city, '-> id:', club.id);
          select1.value = club.id;
          updatePouleLocationLabels();
          return;
        }
      }
      console.log('[preselectLocation] No match found for:', locationName, 'Available clubs:', clubs.map(c => ({ name: c.name, display_name: c.display_name, city: c.city })));
    }

    loadClubs();

    // Location add/remove handlers
    document.getElementById('addLocation2Btn').addEventListener('click', () => {
      document.getElementById('location2Container').style.display = 'block';
      document.getElementById('addLocation2Btn').style.display = 'none';
      updatePouleLocationLabels();
    });

    document.getElementById('removeLocation2Btn').addEventListener('click', () => {
      document.getElementById('location2Container').style.display = 'none';
      document.getElementById('addLocation2Btn').style.display = 'inline-block';
      document.getElementById('locationSelect2').value = '';
      // Reset all poules to location 1
      document.querySelectorAll('.poule-location').forEach(select => select.value = '1');
      updatePouleLocationLabels();
    });

    // Update poule labels when location dropdowns change
    document.getElementById('locationSelect1').addEventListener('change', () => {
      updatePouleLocationLabels();
      // Update summary Lieu when main location changes
      const select = document.getElementById('locationSelect1');
      const selectedOption = select.options[select.selectedIndex];
      if (select.value && selectedOption) {
        document.getElementById('summaryLieu').textContent = selectedOption.dataset.name || selectedOption.text;
      }
    });
    document.getElementById('locationSelect2').addEventListener('change', updatePouleLocationLabels);

    // Update load button state and load tournament info
    function updateLoadButtonState() {
      const categoryId = document.getElementById('categorySelect').value;
      const season = document.getElementById('seasonSelect').value;
      const tournament = document.getElementById('tournamentSelect').value;

      document.getElementById('loadPlayersBtn').disabled = !categoryId || !season || !tournament;

      // Load tournament info if all fields are selected
      if (categoryId && tournament) {
        loadTournamentInfo(categoryId, tournament);
      } else {
        document.getElementById('tournamentInfo').style.display = 'none';
        matchingTournoi = null;
      }
    }

    // Load external tournament info
    async function loadTournamentInfo(categoryId, tournamentNum) {
      const category = categories.find(c => c.id == categoryId);
      if (!category) return;

      // Convert internal level codes to IONOS format
      // Levels in DB: N3GC, R1, R2, R3, R4, N3, etc.
      // IONOS expects: N3, R1, R2, R3, etc.
      // Remove suffixes like GC, HC, JC, SC from level codes
      const ionosLevel = category.level.toUpperCase().replace(/(GC|HC|JC|SC)$/i, '').trim();

      try {
        const response = await fetch(`${API_URL}/inscriptions/tournoi?mode=${category.game_type}&categorie=${ionosLevel}`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });

        if (response.ok) {
          externalTournois = await response.json();

          // If we have a selected tournament from clicking a card, use its ID directly
          const selectedTournoiId = window.selectedUpcomingTournament?.tournoiId;

          // Find matching tournament - prefer using stored tournoiId if available
          const targetName = tournamentNum === '4' ? 'FINALE' : `TOURNOI ${tournamentNum}`;

          if (selectedTournoiId) {
            // First try to find by exact tournoi_id in the API response
            matchingTournoi = externalTournois.find(t => t.tournoi_id == selectedTournoiId);

            // If not found in filtered results, fetch it directly by ID
            if (!matchingTournoi) {
              try {
                const directResponse = await fetch(`${API_URL}/inscriptions/tournoi/${selectedTournoiId}`, {
                  headers: { 'Authorization': `Bearer ${token}` }
                });
                if (directResponse.ok) {
                  matchingTournoi = await directResponse.json();
                }
              } catch (e) {
                console.log('Could not fetch tournament directly:', e);
              }
            }
          }

          // Fallback to name matching if not found by ID
          if (!matchingTournoi) {
            matchingTournoi = externalTournois.find(t =>
              t.nom.toUpperCase().includes(targetName) ||
              (tournamentNum === '4' && t.nom.toUpperCase().includes('FINALE'))
            );
          }

          if (matchingTournoi) {
            // Load inscription count
            const inscResponse = await fetch(`${API_URL}/inscriptions/tournoi/${matchingTournoi.tournoi_id}/inscriptions`, {
              headers: { 'Authorization': `Bearer ${token}` }
            });
            let inscCount = 0;
            if (inscResponse.ok) {
              const inscriptions = await inscResponse.json();
              inscCount = inscriptions.filter(i => i.forfait !== 1).length;
            }

            // Format date
            const dateStr = matchingTournoi.debut
              ? new Date(matchingTournoi.debut).toLocaleDateString('fr-FR', { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric' })
              : 'Non d√©finie';

            document.getElementById('tournamentInfoName').textContent =
              `${category.display_name} - ${matchingTournoi.nom}`;
            document.getElementById('tournamentInfoDate').textContent = dateStr;
            document.getElementById('tournamentInfoLieu').textContent = matchingTournoi.lieu || 'Non d√©fini';
            // For finals, show "X/Y inscrits" (inscribed finalists / total finalists)
            const isFinaleTournoi = matchingTournoi.nom?.toUpperCase().includes('FINALE') || tournamentNum === 'Finale' || isFinale;
            if (isFinaleTournoi && window.selectedUpcomingTournament) {
              const fc = window.selectedUpcomingTournament.finalist_count || 0;
              const ifc = window.selectedUpcomingTournament.inscribed_finalist_count || 0;
              document.getElementById('tournamentInfoInscrits').textContent = `${ifc}/${fc} inscrits`;
            } else {
              document.getElementById('tournamentInfoInscrits').textContent = `${inscCount} joueurs`;
            }
            document.getElementById('tournamentInfo').style.display = 'block';
          } else if (window.selectedUpcomingTournament && (tournamentNum === 'Finale' || isFinale)) {
            // For finals selected from upcoming tournaments card, use stored data
            const upcomingData = window.selectedUpcomingTournament;

            // Create a pseudo matchingTournoi object for finals
            matchingTournoi = {
              tournoi_id: upcomingData.tournoiId,
              nom: 'Finale D√©partementale',
              debut: upcomingData.date,
              lieu: upcomingData.lieu,
              isFinale: true
            };

            // Load inscription count
            let inscCount = 0;
            if (upcomingData.tournoiId) {
              const inscResponse = await fetch(`${API_URL}/inscriptions/tournoi/${upcomingData.tournoiId}/inscriptions`, {
                headers: { 'Authorization': `Bearer ${token}` }
              });
              if (inscResponse.ok) {
                const inscriptions = await inscResponse.json();
                inscCount = inscriptions.filter(i => i.forfait !== 1).length;
              }
            }

            // Format date
            const dateStr = upcomingData.date
              ? new Date(upcomingData.date).toLocaleDateString('fr-FR', { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric' })
              : 'Non d√©finie';

            document.getElementById('tournamentInfoName').textContent =
              `${category.display_name} - Finale D√©partementale`;
            document.getElementById('tournamentInfoDate').textContent = dateStr;
            document.getElementById('tournamentInfoLieu').textContent = upcomingData.lieu || 'Non d√©fini';
            // For finals, show "X/Y inscrits" (inscribed finalists / total finalists)
            const fc = upcomingData.finalist_count || 0;
            const ifc = upcomingData.inscribed_finalist_count || 0;
            document.getElementById('tournamentInfoInscrits').textContent = `${ifc}/${fc} inscrits`;
            document.getElementById('tournamentInfo').style.display = 'block';
          } else {
            document.getElementById('tournamentInfo').style.display = 'none';
          }
        }
      } catch (error) {
        console.error('Error loading tournament info:', error);
        document.getElementById('tournamentInfo').style.display = 'none';
      }
    }

    // Mode selector change - populate levels
    document.getElementById('modeSelect').addEventListener('change', (e) => {
      const selectedMode = e.target.value;
      const levelSelect = document.getElementById('levelSelect');
      const categorySelect = document.getElementById('categorySelect');

      levelSelect.innerHTML = '<option value="">-- S√©lectionner --</option>';
      categorySelect.value = '';

      if (selectedMode) {
        // Filter categories by selected mode and get unique levels
        const levels = categories
          .filter(c => c.game_type === selectedMode)
          .map(c => c.level)
          .filter((v, i, a) => a.indexOf(v) === i)
          .sort();

        levels.forEach(level => {
          levelSelect.innerHTML += `<option value="${level}">${level}</option>`;
        });
      }

      updateLoadButtonState();
    });

    // Level selector change - set category
    document.getElementById('levelSelect').addEventListener('change', (e) => {
      const selectedMode = document.getElementById('modeSelect').value;
      const selectedLevel = e.target.value;
      const categorySelect = document.getElementById('categorySelect');

      if (selectedMode && selectedLevel) {
        // Find the matching category
        const matchingCategory = categories.find(c =>
          c.game_type === selectedMode && c.level === selectedLevel
        );
        if (matchingCategory) {
          categorySelect.value = matchingCategory.id;
        }
      } else {
        categorySelect.value = '';
      }

      updateLoadButtonState();
    });

    document.getElementById('categorySelect').addEventListener('change', updateLoadButtonState);
    document.getElementById('seasonSelect').addEventListener('change', updateLoadButtonState);
    document.getElementById('tournamentSelect').addEventListener('change', updateLoadButtonState);

    // Load players for selected category
    document.getElementById('loadPlayersBtn').addEventListener('click', async () => {
      const categoryId = document.getElementById('categorySelect').value;
      const season = document.getElementById('seasonSelect').value;
      const tournamentNum = document.getElementById('tournamentSelect').value;

      currentCategory = categories.find(c => c.id == categoryId);
      currentSeason = season;
      currentTournament = tournamentNum;

      // Check if this is a finale
      const isFinaleCompetition = isFinale || tournamentNum === 'Finale' || tournamentNum === '4';

      // Determine which ranking to load based on tournament number
      const previousTournament = parseInt(tournamentNum) - 1;

      try {
        // For FINALE: Load full rankings and take top 4 or 6 finalists
        if (isFinaleCompetition) {
          const rankingResponse = await fetch(`${API_URL}/rankings?categoryId=${categoryId}&season=${season}`, {
            headers: { 'Authorization': `Bearer ${token}` }
          });

          if (rankingResponse.ok) {
            const data = await rankingResponse.json();
            const rankings = data.rankings || [];

            // Determine number of finalists: 6 if enough participants, otherwise 4
            // Count unique participants across all 3 tournaments
            const totalParticipants = rankings.length;
            const numFinalists = totalParticipants >= 10 ? 6 : 4;

            // Take only top N finalists
            // Include email from player_contacts for finale convocations
            rankedPlayers = rankings.slice(0, numFinalists).map((r, index) => ({
              licence: r.licence,
              first_name: r.first_name,
              last_name: r.last_name,
              club: r.club,
              rank: r.rank_position,
              total_match_points: r.total_match_points,
              email: r.contact_email || null,
              telephone: r.contact_telephone || null,
              isRanked: true,
              isFinalist: true
            }));
          }
        }
        // For regular tournaments (T2, T3): Load ranking from previous tournament(s)
        else if (previousTournament >= 1) {
          const rankingResponse = await fetch(`${API_URL}/rankings?categoryId=${categoryId}&season=${season}`, {
            headers: { 'Authorization': `Bearer ${token}` }
          });

          if (rankingResponse.ok) {
            const data = await rankingResponse.json();
            const rankings = data.rankings || [];
            rankedPlayers = rankings.map((r, index) => ({
              licence: r.licence,
              first_name: r.first_name,
              last_name: r.last_name,
              club: r.club,
              rank: r.rank_position,
              total_match_points: r.total_match_points,
              isRanked: true
            }));
          }
        } else {
          // T1 - no previous ranking, would need to use player list
          rankedPlayers = [];
        }

        // Load inscriptions using the already-matched tournament
        if (matchingTournoi) {
          const inscriptionsResponse = await fetch(`${API_URL}/inscriptions/tournoi/${matchingTournoi.tournoi_id}/inscriptions`, {
            headers: { 'Authorization': `Bearer ${token}` }
          });

          // Fetch player emails for email convocations
          fetchPlayerEmails(matchingTournoi.tournoi_id);

          if (inscriptionsResponse.ok) {
            const inscriptions = await inscriptionsResponse.json();

            // For FINALE: Don't show "new players" section - only finalists matter
            if (isFinaleCompetition) {
              newPlayers = [];

              // Mark finalists who have inscribed AND auto-select ALL finalists
              // (convocation is sent to all qualified, regardless of inscription status)
              rankedPlayers.forEach(p => {
                const inscription = inscriptions.find(i =>
                  i.licence?.replace(/\s/g, '') === p.licence?.replace(/\s/g, '')
                );
                if (inscription) {
                  p.isInscribed = true;
                  p.forfait = inscription.forfait === 1;
                  p.desinscrit = inscription.statut === 'd√©sinscrit';
                  p.inscription_id = inscription.inscription_id;
                }
                // Auto-select ALL finalists (not forfait and not d√©sinscrit)
                // They need to receive convocation whether inscribed or not
                if (!p.forfait && !p.desinscrit) {
                  p.selected = true;
                }
              });
            } else {
              // Regular tournament logic
              // Find new players (inscribed but not in ranking) - include d√©sinscrit to show them grayed out
              const rankedLicences = new Set(rankedPlayers.map(p => p.licence.replace(/\s/g, '')));

              newPlayers = inscriptions
                .filter(i => !rankedLicences.has(i.licence?.replace(/\s/g, '')) && i.forfait !== 1)
                .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp))
                .map((i, index) => ({
                  licence: i.licence,
                  first_name: i.first_name || 'Inconnu',
                  last_name: i.last_name || 'Inconnu',
                  club: i.club || '',
                  timestamp: i.timestamp,
                  isNew: true,
                  forfait: i.forfait,
                  desinscrit: i.statut === 'd√©sinscrit',
                  inscription_id: i.inscription_id
                }));

              // Mark ranked players who are inscribed or forfait AND auto-select them
              rankedPlayers.forEach(p => {
                const inscription = inscriptions.find(i =>
                  i.licence?.replace(/\s/g, '') === p.licence?.replace(/\s/g, '')
                );
                if (inscription) {
                  p.isInscribed = true;
                  p.forfait = inscription.forfait === 1;
                  p.desinscrit = inscription.statut === 'd√©sinscrit';
                  p.inscription_id = inscription.inscription_id;
                  // Auto-select inscribed players (not forfait and not d√©sinscrit)
                  if (!p.forfait && !p.desinscrit) {
                    p.selected = true;
                  }
                }
              });

              // Auto-select new players (except d√©sinscrit ones)
              newPlayers.forEach(p => {
                if (!p.desinscrit) {
                  p.selected = true;
                }
              });
            }
          }
        } else {
          // No matching external tournament found - clear new players
          newPlayers = [];
        }

        // Load all system players for last minute search (in separate try-catch to avoid breaking main flow)
        try {
          const allPlayersResponse = await fetch(`${API_URL}/players`, {
            headers: { 'Authorization': `Bearer ${token}` }
          });
          if (allPlayersResponse.ok) {
            allSystemPlayers = await allPlayersResponse.json();
          }
        } catch (e) {
          console.error('Error loading all players:', e);
        }

        // Reset last minute players
        lastMinutePlayers = [];
        selectedLastMinutePlayer = null;

        // Reset forfait flow flag (normal flow)
        cameFromForfait = false;

        renderPlayerLists();
        goToStep(2);

      } catch (error) {
        console.error('Error loading players:', error);
        document.getElementById('errorMessage').textContent = 'Erreur lors du chargement des joueurs';
        document.getElementById('errorMessage').style.display = 'block';
      }
    });

    // Render player lists
    function renderPlayerLists() {
      const rankedList = document.getElementById('rankedPlayersList');
      const newList = document.getElementById('newPlayersList');
      const rankedTitle = document.getElementById('rankedPlayersTitle');
      const newPlayersTitle = document.getElementById('newPlayersTitle');
      const newPlayersSection = newList.parentElement;

      // Check if this is a finale
      const isFinaleCompetition = isFinale || currentTournament === 'Finale' || currentTournament === '4';

      // Update titles based on competition type
      if (isFinaleCompetition) {
        rankedTitle.textContent = `üèÜ Finalistes qualifi√©s (${rankedPlayers.length} joueurs)`;
        newPlayersTitle.style.display = 'none';
        newList.style.display = 'none';
      } else {
        rankedTitle.textContent = 'Joueurs class√©s (du classement actuel)';
        newPlayersTitle.style.display = 'block';
        newList.style.display = 'block';
      }

      if (rankedPlayers.length === 0) {
        rankedList.innerHTML = isFinaleCompetition
          ? '<p style="padding: 20px; color: #666; text-align: center;">Aucun classement disponible - Impossible de d√©terminer les finalistes</p>'
          : '<p style="padding: 20px; color: #666; text-align: center;">Aucun classement disponible pour ce tournoi</p>';
      } else {
        rankedList.innerHTML = rankedPlayers.map((p, index) => `
          <div class="player-item ${p.selected ? 'selected' : ''} ${p.forfait ? 'forfait' : ''} ${p.desinscrit ? 'desinscrit' : ''} ${!p.isInscribed && isFinaleCompetition ? 'not-inscribed' : ''}"
               data-licence="${p.licence}" data-type="ranked" data-index="${index}" data-inscription-id="${p.inscription_id || ''}"
               style="${!p.isInscribed && isFinaleCompetition ? 'background: #fff3cd;' : ''} ${p.desinscrit ? 'opacity: 0.5; text-decoration: line-through;' : ''}">
            <input type="checkbox" ${p.selected ? 'checked' : ''} ${p.forfait || p.desinscrit ? 'disabled' : ''}>
            <span class="player-rank">#${p.rank}</span>
            <span class="player-name">${p.last_name} ${p.first_name}</span>
            <span class="player-club">${p.club || ''}</span>
            <span class="player-licence">${p.licence}</span>
            ${p.isFinalist ? '<span class="badge" style="background: #ffc107; color: #333;">Finaliste</span>' : ''}
            ${p.forfait ? '<span class="badge badge-forfait">Forfait</span>' :
              (p.desinscrit ? '<span class="badge" style="background: #6c757d; color: white;">D√©sinscrit</span><button class="btn-reinscription" data-inscription-id="' + p.inscription_id + '" title="R√©tablir inscription" style="margin-left: 5px; padding: 2px 8px; font-size: 11px; background: #28a745; color: white; border: none; border-radius: 3px; cursor: pointer;">R√©inscrire</button>' :
                (p.isInscribed ? '<span class="badge badge-inscrit">Inscrit</span><button class="btn-desinscription" data-inscription-id="' + p.inscription_id + '" title="D√©sinscrire ce joueur" style="margin-left: 5px; padding: 2px 6px; font-size: 11px; background: #dc3545; color: white; border: none; border-radius: 3px; cursor: pointer;">‚úï</button>' :
                  (isFinaleCompetition ? '<span class="badge" style="background: #dc3545; color: white;">Non inscrit</span>' : '')))}
          </div>
        `).join('');
      }

      if (newPlayers.length === 0) {
        newList.innerHTML = '<p style="padding: 20px; color: #666; text-align: center;">Aucun nouveau joueur inscrit</p>';
      } else {
        newList.innerHTML = newPlayers.map((p, index) => `
          <div class="player-item new-player ${p.selected ? 'selected' : ''} ${p.desinscrit ? 'desinscrit' : ''}"
               data-licence="${p.licence}" data-type="new" data-index="${index}" data-inscription-id="${p.inscription_id || ''}"
               style="${p.desinscrit ? 'opacity: 0.5; text-decoration: line-through;' : ''}">
            <input type="checkbox" ${p.selected ? 'checked' : ''} ${p.desinscrit ? 'disabled' : ''}>
            <span class="player-rank">-</span>
            <span class="player-name">${p.last_name} ${p.first_name}</span>
            <span class="player-club">${p.club || ''}</span>
            <span class="player-licence">${p.licence}</span>
            ${p.desinscrit
              ? '<span class="badge" style="background: #6c757d; color: white;">D√©sinscrit</span><button class="btn-reinscription" data-inscription-id="' + p.inscription_id + '" title="R√©tablir inscription" style="margin-left: 5px; padding: 2px 8px; font-size: 11px; background: #28a745; color: white; border: none; border-radius: 3px; cursor: pointer;">R√©inscrire</button>'
              : '<span class="badge badge-new">Nouveau</span><button class="btn-desinscription" data-inscription-id="' + p.inscription_id + '" title="D√©sinscrire ce joueur" style="margin-left: 5px; padding: 2px 6px; font-size: 11px; background: #dc3545; color: white; border: none; border-radius: 3px; cursor: pointer;">‚úï</button>'}
          </div>
        `).join('');
      }

      // Render last minute players
      const lastMinuteList = document.getElementById('lastMinutePlayersList');
      if (lastMinuteList) {
        if (lastMinutePlayers.length === 0) {
          lastMinuteList.innerHTML = '';
        } else {
          lastMinuteList.innerHTML = lastMinutePlayers.map((p, index) => `
            <div class="player-item new-player ${p.selected ? 'selected' : ''}"
                 data-licence="${p.licence}" data-type="lastMinute" data-index="${index}">
              <input type="checkbox" ${p.selected ? 'checked' : ''}>
              <span class="player-rank">-</span>
              <span class="player-name">${p.last_name} ${p.first_name}</span>
              <span class="player-club">${p.club || ''}</span>
              <span class="player-licence">${p.licence}</span>
              <span class="badge" style="background: #dc3545; color: white;">Last minute</span>
              <button class="btn-remove-lastminute" data-index="${index}" style="margin-left: auto; background: none; border: none; color: #dc3545; cursor: pointer; font-size: 18px;" title="Retirer">√ó</button>
            </div>
          `).join('');

          // Add remove handlers for last minute players
          lastMinuteList.querySelectorAll('.btn-remove-lastminute').forEach(btn => {
            btn.addEventListener('click', (e) => {
              e.stopPropagation();
              const idx = parseInt(btn.dataset.index);
              lastMinutePlayers.splice(idx, 1);
              renderPlayerLists();
            });
          });
        }
      }

      // Add click handlers
      document.querySelectorAll('.player-item').forEach(item => {
        item.addEventListener('click', (e) => {
          if (e.target.type === 'checkbox') return;
          if (item.classList.contains('forfait')) return;
          if (item.classList.contains('desinscrit')) return;
          // Ignore clicks on desinscription/reinscription buttons
          if (e.target.classList.contains('btn-desinscription') || e.target.classList.contains('btn-reinscription')) return;

          const checkbox = item.querySelector('input[type="checkbox"]');
          checkbox.checked = !checkbox.checked;
          togglePlayerSelection(item);
        });

        item.querySelector('input[type="checkbox"]').addEventListener('change', () => {
          togglePlayerSelection(item);
        });
      });

      // Add desinscription button handlers
      document.querySelectorAll('.btn-desinscription').forEach(btn => {
        btn.addEventListener('click', async (e) => {
          e.stopPropagation();
          const inscriptionId = btn.dataset.inscriptionId;
          const playerItem = btn.closest('.player-item');
          const playerName = playerItem.querySelector('.player-name').textContent;

          if (!confirm(`Voulez-vous d√©sinscrire ${playerName} de ce tournoi ?`)) return;

          try {
            const response = await fetch(`${API_URL}/inscriptions/${inscriptionId}/desinscription`, {
              method: 'PUT',
              headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({ statut: 'd√©sinscrit' })
            });

            if (response.ok) {
              // Update local data and re-render
              const index = parseInt(playerItem.dataset.index);
              const type = playerItem.dataset.type;
              if (type === 'ranked') {
                rankedPlayers[index].desinscrit = true;
                rankedPlayers[index].selected = false;
              } else if (type === 'new') {
                newPlayers[index].desinscrit = true;
                newPlayers[index].selected = false;
              }
              renderPlayerLists();
              // Show success message
              const msgEl = document.getElementById('successMessage');
              msgEl.textContent = `‚úì ${playerName} a √©t√© d√©sinscrit`;
              msgEl.style.display = 'block';
              setTimeout(() => msgEl.style.display = 'none', 3000);
            } else {
              const error = await response.json();
              alert(error.error || 'Erreur lors de la d√©sinscription');
            }
          } catch (error) {
            console.error('Error:', error);
            alert('Erreur lors de la d√©sinscription');
          }
        });
      });

      // Add reinscription button handlers
      document.querySelectorAll('.btn-reinscription').forEach(btn => {
        btn.addEventListener('click', async (e) => {
          e.stopPropagation();
          const inscriptionId = btn.dataset.inscriptionId;
          const playerItem = btn.closest('.player-item');
          const playerName = playerItem.querySelector('.player-name').textContent;

          if (!confirm(`Voulez-vous r√©tablir l'inscription de ${playerName} ?`)) return;

          try {
            const response = await fetch(`${API_URL}/inscriptions/${inscriptionId}/desinscription`, {
              method: 'PUT',
              headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({ statut: 'inscrit' })
            });

            if (response.ok) {
              // Update local data and re-render
              const index = parseInt(playerItem.dataset.index);
              const type = playerItem.dataset.type;
              if (type === 'ranked') {
                rankedPlayers[index].desinscrit = false;
                rankedPlayers[index].selected = true;
              } else if (type === 'new') {
                newPlayers[index].desinscrit = false;
                newPlayers[index].selected = true;
              }
              renderPlayerLists();
              // Show success message
              const msgEl = document.getElementById('successMessage');
              msgEl.textContent = `‚úì Inscription de ${playerName} r√©tablie`;
              msgEl.style.display = 'block';
              setTimeout(() => msgEl.style.display = 'none', 3000);
            } else {
              const error = await response.json();
              alert(error.error || 'Erreur lors du r√©tablissement');
            }
          } catch (error) {
            console.error('Error:', error);
            alert('Erreur lors du r√©tablissement');
          }
        });
      });

      updateSelectionSummary();
    }

    function togglePlayerSelection(item) {
      const type = item.dataset.type;
      const index = parseInt(item.dataset.index);
      const checkbox = item.querySelector('input[type="checkbox"]');

      if (type === 'ranked') {
        rankedPlayers[index].selected = checkbox.checked;
      } else if (type === 'lastMinute') {
        lastMinutePlayers[index].selected = checkbox.checked;
      } else {
        newPlayers[index].selected = checkbox.checked;
      }

      item.classList.toggle('selected', checkbox.checked);
      updateSelectionSummary();
    }

    function updateSelectionSummary() {
      const selectedRanked = rankedPlayers.filter(p => p.selected);
      const selectedNew = newPlayers.filter(p => p.selected);
      const selectedLastMinute = lastMinutePlayers.filter(p => p.selected);
      const totalSelected = selectedRanked.length + selectedNew.length + selectedLastMinute.length;

      document.getElementById('selectedCount').textContent = totalSelected;

      if (totalSelected >= 3) {
        // For finals: always show "1 poule unique" since all finalists play together
        if (isFinale) {
          document.getElementById('pouleConfig').textContent = '1 poule unique (tous contre tous)';
          document.getElementById('tablesNeeded').textContent = '1';
        } else {
          const config = getPouleConfig(totalSelected);
          document.getElementById('pouleConfig').textContent = config.description;
          document.getElementById('tablesNeeded').textContent = config.tables;
        }
        document.getElementById('validatePlayersBtn').disabled = false;
      } else {
        document.getElementById('pouleConfig').textContent = '-';
        document.getElementById('tablesNeeded').textContent = '-';
        document.getElementById('validatePlayersBtn').disabled = true;
      }
    }

    // Selection buttons
    document.getElementById('selectAllBtn').addEventListener('click', () => {
      rankedPlayers.forEach(p => { if (!p.forfait) p.selected = true; });
      newPlayers.forEach(p => p.selected = true);
      lastMinutePlayers.forEach(p => p.selected = true);
      renderPlayerLists();
    });

    document.getElementById('deselectAllBtn').addEventListener('click', () => {
      rankedPlayers.forEach(p => p.selected = false);
      newPlayers.forEach(p => p.selected = false);
      lastMinutePlayers.forEach(p => p.selected = false);
      renderPlayerLists();
    });

    document.getElementById('selectRegisteredBtn').addEventListener('click', () => {
      rankedPlayers.forEach(p => {
        p.selected = p.isInscribed && !p.forfait;
      });
      newPlayers.forEach(p => p.selected = true);
      lastMinutePlayers.forEach(p => p.selected = true);
      renderPlayerLists();
    });

    // Navigation
    function goToStep(stepNum) {
      document.querySelectorAll('.card[id^="step"]').forEach(card => card.style.display = 'none');
      document.getElementById(`step${stepNum}`).style.display = 'block';

      // Hide upcoming tournaments when leaving step 1, show it when returning to step 1
      const upcomingCard = document.getElementById('upcomingTournamentsCard');
      if (upcomingCard) {
        upcomingCard.style.display = stepNum === 1 ? 'block' : 'none';
      }

      document.querySelectorAll('.step').forEach((step, index) => {
        step.classList.remove('active', 'completed');
        if (index + 1 < stepNum) step.classList.add('completed');
        if (index + 1 === stepNum) step.classList.add('active');
      });
    }

    document.getElementById('backToStep1Btn').addEventListener('click', () => goToStep(1));
    document.getElementById('backToStep2Btn').addEventListener('click', () => {
      if (cameFromForfait) {
        // Return to forfait modal instead of Step 2
        // Hide Step 3 first
        document.getElementById('step3').style.display = 'none';
        openForfaitModal();
      } else {
        goToStep(2);
      }
    });
    document.getElementById('backToStep3Btn').addEventListener('click', () => goToStep(3));
    document.getElementById('newGenerationBtn').addEventListener('click', () => {
      // Reset state
      rankedPlayers = [];
      newPlayers = [];
      lastMinutePlayers = [];
      selectedPlayers = [];
      // Clear save poules result message
      const savePoulesResult = document.getElementById('savePoulesResult');
      if (savePoulesResult) {
        savePoulesResult.style.display = 'none';
        savePoulesResult.innerHTML = '';
      }
      // Clear email results too
      const emailResults = document.getElementById('emailResults');
      if (emailResults) {
        emailResults.style.display = 'none';
        emailResults.innerHTML = '';
      }
      goToStep(1);
    });

    // Validate and preview
    document.getElementById('validatePlayersBtn').addEventListener('click', () => {
      // Build final player list with re-ranking
      selectedPlayers = [];

      // First add selected ranked players (maintaining their rank order but re-numbering)
      let newRank = 1;
      rankedPlayers.filter(p => p.selected).forEach(p => {
        selectedPlayers.push({
          ...p,
          finalRank: newRank++
        });
      });

      // Then add new players sorted by timestamp
      newPlayers.filter(p => p.selected).forEach(p => {
        selectedPlayers.push({
          ...p,
          finalRank: newRank++
        });
      });

      // Then add last minute players
      lastMinutePlayers.filter(p => p.selected).forEach(p => {
        selectedPlayers.push({
          ...p,
          finalRank: newRank++,
          isLastMinute: true
        });
      });

      // Update summary
      document.getElementById('summaryCategory').textContent = currentCategory.display_name;
      const isFinale = currentTournament === 'Finale' || currentTournament === '4' ||
                       (window.selectedUpcomingTournament && window.selectedUpcomingTournament.isFinale);
      document.getElementById('summaryTournament').textContent =
        isFinale ? 'Finale D√©partementale' : `Tournoi ${currentTournament}`;

      // Store isFinale globally for later use
      window.currentCompetitionIsFinale = isFinale;

      // Add tournament date and lieu from external tournament
      if (matchingTournoi) {
        const dateStr = matchingTournoi.debut
          ? new Date(matchingTournoi.debut).toLocaleDateString('fr-FR', { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric' })
          : 'Non d√©finie';
        document.getElementById('summaryDate').textContent = dateStr;
        document.getElementById('summaryLieu').textContent = matchingTournoi.lieu || 'Non d√©fini';
      } else {
        document.getElementById('summaryDate').textContent = 'Non d√©finie';
        document.getElementById('summaryLieu').textContent = 'Non d√©fini';
      }

      document.getElementById('summaryPlayers').textContent = selectedPlayers.length;

      let poules;
      let configDescription;
      let tablesNeeded;

      if (isFinale) {
        // For finals: single poule with all players (no serpentine distribution)
        poules = [{
          number: 1,
          size: selectedPlayers.length,
          players: selectedPlayers.map((p, idx) => ({
            ...p,
            pouleRank: idx + 1
          }))
        }];
        configDescription = `1 poule unique de ${selectedPlayers.length} joueurs (Finale)`;
        tablesNeeded = 1;

        // Update the poule preview title for finale
        document.getElementById('poulePreviewTitle').innerHTML = 'Aper√ßu de la Poule Unique (Finale - Tous contre tous)';
      } else {
        // For regular tournaments: serpentine distribution
        const config = getPouleConfig(selectedPlayers.length);
        poules = distributeSerpentine(selectedPlayers, config.poules);
        configDescription = config.description;
        tablesNeeded = config.tables;

        // Reset the poule preview title
        document.getElementById('poulePreviewTitle').innerHTML = 'Aper√ßu des Poules (Distribution Serpentine)';
      }

      document.getElementById('summaryConfig').textContent = configDescription;
      document.getElementById('summaryTables').textContent = tablesNeeded;

      // Generate poule preview
      renderPoulePreview(poules);

      // Pre-select location from tournament file
      if (matchingTournoi && matchingTournoi.lieu) {
        preselectLocation(matchingTournoi.lieu);
      }

      // Reset second location
      document.getElementById('location2Container').style.display = 'none';
      document.getElementById('addLocation2Btn').style.display = 'inline-block';
      document.getElementById('locationSelect2').value = '';

      // Load game parameters for this category
      loadGameParameters();

      goToStep(3);
    });

    // Load and display game parameters for the current category
    async function loadGameParameters() {
      if (!currentCategory) {
        document.getElementById('gameParamsSection').style.display = 'none';
        return;
      }

      try {
        // URL encode parameters and uppercase for consistent lookup
        const mode = encodeURIComponent(currentCategory.game_type.toUpperCase());
        const level = encodeURIComponent(currentCategory.level.toUpperCase());
        const response = await fetch(`${API_URL}/settings/game-parameters/${mode}/${level}`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });

        if (!response.ok) {
          document.getElementById('gameParamsSection').style.display = 'none';
          currentGameParams = null;
          return;
        }

        currentGameParams = await response.json();

        // Show the game parameters section
        document.getElementById('gameParamsSection').style.display = 'block';

        // Update distance selector
        const distanceSelect = document.getElementById('distanceSelect');
        distanceSelect.innerHTML = `<option value="normale">${currentGameParams.distance_normale} points (Distance normale)</option>`;
        if (currentGameParams.distance_reduite) {
          distanceSelect.innerHTML += `<option value="reduite">${currentGameParams.distance_reduite} points (Distance r√©duite)</option>`;
        }

        // Update coin display
        const coinSpan = document.getElementById('gameParamCoin');
        if (currentGameParams.coin === 'GC') {
          coinSpan.textContent = 'Grand Coin';
          coinSpan.style.background = '#ffc107';
          coinSpan.style.color = '#000';
        } else if (currentGameParams.coin === 'PC') {
          coinSpan.textContent = 'Petit Coin';
          coinSpan.style.background = '#17a2b8';
          coinSpan.style.color = '#fff';
        } else {
          coinSpan.textContent = '-';
          coinSpan.style.background = '#6c757d';
          coinSpan.style.color = '#fff';
        }

        // Update reprises
        document.getElementById('gameParamReprises').textContent = currentGameParams.reprises;

        // Update moyenne info
        document.getElementById('gameParamMoyenne').textContent =
          `La moyenne qualificative pour cette cat√©gorie est entre ${parseFloat(currentGameParams.moyenne_mini).toFixed(3)} et ${parseFloat(currentGameParams.moyenne_maxi).toFixed(3)}`;

      } catch (error) {
        console.error('Error loading game parameters:', error);
        document.getElementById('gameParamsSection').style.display = 'none';
        currentGameParams = null;
      }
    }

    // Store current poules globally for manipulation
    let currentPoules = [];

    function renderPoulePreview(poules) {
      currentPoules = poules;
      const container = document.getElementById('poulePreview');
      const numPoules = poules.length;

      container.innerHTML = poules.map(poule => `
        <div class="poule-card" data-poule="${poule.number}">
          <h4>Poule ${poule.number} (${poule.players.length} joueurs)</h4>
          ${poule.players.map((p, index) => `
            <div class="poule-player" data-licence="${p.licence}" data-poule="${poule.number}">
              <span class="poule-player-rank">${index + 1}.</span>
              <span style="flex: 1;">${p.last_name} ${p.first_name} <strong style="color: #1F4788;">(${p.finalRank})</strong></span>
              ${p.isLastMinute ? '<span class="badge" style="background: #dc3545; color: white;">Last minute</span>' : (p.isNew ? '<span class="badge badge-new">Nouveau</span>' : '')}
              ${numPoules > 1 ? `
                <select class="move-player-select" data-licence="${p.licence}" data-from-poule="${poule.number}"
                        style="padding: 2px 5px; font-size: 0.75em; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;">
                  <option value="">D√©placer...</option>
                  ${poules.filter(op => op.number !== poule.number).map(op =>
                    `<option value="${op.number}">‚Üí Poule ${op.number}</option>`
                  ).join('')}
                </select>
              ` : ''}
            </div>
          `).join('')}
          <div class="poule-location-select" style="margin-top: 10px; padding-top: 10px; border-top: 1px dashed #ddd;">
            <select class="poule-location" data-poule="${poule.number}" style="width: 100%; padding: 5px; border: 1px solid #ddd; border-radius: 4px; font-size: 0.85em;">
              <option value="1">Lieu 1</option>
              <option value="2">Lieu 2</option>
            </select>
          </div>
        </div>
      `).join('');

      // Add move player handlers
      container.querySelectorAll('.move-player-select').forEach(select => {
        select.addEventListener('change', (e) => {
          const licence = select.dataset.licence;
          const fromPoule = parseInt(select.dataset.fromPoule);
          const toPoule = parseInt(e.target.value);

          if (toPoule) {
            movePlayerBetweenPoules(licence, fromPoule, toPoule);
          }
          // Reset select
          select.value = '';
        });
      });

      // Update location labels when locations change
      updatePouleLocationLabels();
    }

    function movePlayerBetweenPoules(licence, fromPouleNum, toPouleNum) {
      // Find the player in the source poule
      const fromPoule = currentPoules.find(p => p.number === fromPouleNum);
      const toPoule = currentPoules.find(p => p.number === toPouleNum);

      if (!fromPoule || !toPoule) return;

      const playerIndex = fromPoule.players.findIndex(p => p.licence === licence);
      if (playerIndex === -1) return;

      // Remove from source poule
      const [player] = fromPoule.players.splice(playerIndex, 1);

      // Add to destination poule
      toPoule.players.push(player);

      // Re-render
      renderPoulePreview(currentPoules);

      // Show success message briefly
      const msg = document.getElementById('successMessage');
      msg.textContent = `${player.last_name} ${player.first_name} d√©plac√© vers Poule ${toPouleNum}`;
      msg.style.display = 'block';
      setTimeout(() => msg.style.display = 'none', 2000);
    }

    function updatePouleLocationLabels() {
      const location1Select = document.getElementById('locationSelect1');
      const location2Select = document.getElementById('locationSelect2');
      const location2Container = document.getElementById('location2Container');

      const loc1Name = location1Select.value ?
        location1Select.options[location1Select.selectedIndex]?.text : 'Lieu 1';
      const loc2Name = location2Select.value ?
        location2Select.options[location2Select.selectedIndex]?.text : 'Lieu 2';

      const hasSecondLocation = location2Container.style.display !== 'none' && location2Select.value;

      document.querySelectorAll('.poule-location').forEach(select => {
        select.innerHTML = `
          <option value="1">${loc1Name || 'Lieu 1'}</option>
          ${hasSecondLocation ? `<option value="2">${loc2Name || 'Lieu 2'}</option>` : ''}
        `;
      });
    }

    // Generate Excel
    document.getElementById('generateExcelBtn').addEventListener('click', async () => {
      const config = getPouleConfig(selectedPlayers.length);
      // Use currentPoules which may have been modified by moving players
      const poules = currentPoules.length > 0 ? currentPoules : distributeSerpentine(selectedPlayers, config.poules);

      // Get selected locations and times
      const location1Select = document.getElementById('locationSelect1');
      const loc1Option = location1Select.options[location1Select.selectedIndex];
      const location1 = location1Select.value ? {
        id: location1Select.value,
        name: loc1Option.dataset.name,
        street: loc1Option.dataset.street,
        city: loc1Option.dataset.city,
        zip_code: loc1Option.dataset.zipcode,
        phone: loc1Option.dataset.phone,
        email: loc1Option.dataset.email,
        address: loc1Option.dataset.address
      } : null;

      const location2Select = document.getElementById('locationSelect2');
      const loc2Option = location2Select.options[location2Select.selectedIndex];
      const location2 = location2Select.value ? {
        id: location2Select.value,
        name: loc2Option.dataset.name,
        street: loc2Option.dataset.street,
        city: loc2Option.dataset.city,
        zip_code: loc2Option.dataset.zipcode,
        phone: loc2Option.dataset.phone,
        email: loc2Option.dataset.email,
        address: loc2Option.dataset.address
      } : null;

      const startTime1 = document.getElementById('startTime1').value || '13:30';
      const startTime2 = document.getElementById('startTime2').value || '13:30';

      // Get poule location assignments
      const pouleAssignments = {};
      document.querySelectorAll('.poule-location').forEach(select => {
        const pouleNum = select.dataset.poule;
        pouleAssignments[pouleNum] = select.value; // '1' or '2'
      });

      // Add location assignment to each poule
      poules.forEach(poule => {
        poule.locationNum = pouleAssignments[poule.number] || '1';
      });

      try {
        const response = await fetch(`${API_URL}/inscriptions/generate-poules`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            category: currentCategory,
            season: currentSeason,
            tournament: currentTournament,
            players: selectedPlayers,
            poules: poules,
            config: config,
            tournamentDate: matchingTournoi?.debut || null,
            tournamentLieu: matchingTournoi?.lieu || null,
            locations: [
              location1 ? { ...location1, startTime: startTime1, locationNum: '1' } : null,
              location2 ? { ...location2, startTime: startTime2, locationNum: '2' } : null
            ].filter(Boolean)
          })
        });

        if (response.ok) {
          // Download the file
          const blob = await response.blob();
          const url = window.URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `Poules_${currentCategory.display_name}_T${currentTournament}_${currentSeason}.xlsx`;
          document.body.appendChild(a);
          a.click();
          a.remove();
          window.URL.revokeObjectURL(url);

          // Excel downloaded successfully - stay on Step 3
        } else {
          const error = await response.json();
          document.getElementById('errorMessage').textContent = error.error || 'Erreur lors de la g√©n√©ration';
          document.getElementById('errorMessage').style.display = 'block';
        }
      } catch (error) {
        console.error('Error generating Excel:', error);
        document.getElementById('errorMessage').textContent = 'Erreur lors de la g√©n√©ration du fichier';
        document.getElementById('errorMessage').style.display = 'block';
      }
    });

    // Go to Email screen (Step 4)
    document.getElementById('goToEmailBtn').addEventListener('click', () => {
      const config = getPouleConfig(selectedPlayers.length);
      const poules = currentPoules.length > 0 ? currentPoules : distributeSerpentine(selectedPlayers, config.poules);

      // Get selected locations and times
      const location1Select = document.getElementById('locationSelect1');
      const loc1Option = location1Select.options[location1Select.selectedIndex];
      const location1 = location1Select.value ? {
        id: location1Select.value,
        name: loc1Option.dataset.name,
        street: loc1Option.dataset.street,
        city: loc1Option.dataset.city,
        zip_code: loc1Option.dataset.zipcode,
        phone: loc1Option.dataset.phone,
        email: loc1Option.dataset.email,
        address: loc1Option.dataset.address
      } : null;

      const location2Select = document.getElementById('locationSelect2');
      const loc2Option = location2Select.options[location2Select.selectedIndex];
      const location2 = location2Select.value ? {
        id: location2Select.value,
        name: loc2Option.dataset.name,
        street: loc2Option.dataset.street,
        city: loc2Option.dataset.city,
        zip_code: loc2Option.dataset.zipcode,
        phone: loc2Option.dataset.phone,
        email: loc2Option.dataset.email,
        address: loc2Option.dataset.address
      } : null;

      const startTime1 = document.getElementById('startTime1').value || '13:30';
      const startTime2 = document.getElementById('startTime2').value || '13:30';

      // Get poule location assignments
      const pouleAssignments = {};
      document.querySelectorAll('.poule-location').forEach(select => {
        const pouleNum = select.dataset.poule;
        pouleAssignments[pouleNum] = select.value; // '1' or '2'
      });

      // Add location assignment to each poule
      poules.forEach(poule => {
        poule.locationNum = pouleAssignments[poule.number] || '1';
      });

      // Store data for email functionality
      const selectedDistance = document.getElementById('distanceSelect')?.value || 'normale';
      storeGenerationData({
        poules: poules,
        tournamentDate: matchingTournoi?.debut || null,
        tournoiId: matchingTournoi?.tournoi_id || null,
        locations: [
          location1 ? { ...location1, startTime: startTime1, locationNum: '1' } : null,
          location2 ? { ...location2, startTime: startTime2, locationNum: '2' } : null
        ].filter(Boolean),
        gameParams: currentGameParams,
        selectedDistance: selectedDistance
      });

      goToStep(4);
      updateEmailStats();
    });

    // Generate Summary PDF (neutral - no personalization)
    document.getElementById('generateSummaryPdfBtn').addEventListener('click', async () => {
      const config = getPouleConfig(selectedPlayers.length);
      const poules = currentPoules.length > 0 ? currentPoules : distributeSerpentine(selectedPlayers, config.poules);

      // Get selected locations and times
      const location1Select = document.getElementById('locationSelect1');
      const loc1Option = location1Select.options[location1Select.selectedIndex];
      const location1 = location1Select.value ? {
        id: location1Select.value,
        name: loc1Option.dataset.name,
        street: loc1Option.dataset.street,
        city: loc1Option.dataset.city,
        zip_code: loc1Option.dataset.zipcode
      } : null;

      const location2Select = document.getElementById('locationSelect2');
      const loc2Option = location2Select.options[location2Select.selectedIndex];
      const location2 = location2Select.value ? {
        id: location2Select.value,
        name: loc2Option.dataset.name,
        street: loc2Option.dataset.street,
        city: loc2Option.dataset.city,
        zip_code: loc2Option.dataset.zipcode
      } : null;

      const startTime1 = document.getElementById('startTime1').value || '13:30';
      const startTime2 = document.getElementById('startTime2').value || '13:30';

      // Get poule location assignments
      const pouleAssignments = {};
      document.querySelectorAll('.poule-location').forEach(select => {
        const pouleNum = select.dataset.poule;
        pouleAssignments[pouleNum] = select.value;
      });

      poules.forEach(poule => {
        poule.locationNum = pouleAssignments[poule.number] || '1';
      });

      const selectedDistance = document.getElementById('distanceSelect')?.value || 'normale';

      // Check for TEST players and inject mock ranking data
      const hasTestPlayers = poules.some(p => p.players.some(pl => pl.licence?.startsWith('TEST')));
      let mockRankingData = null;
      if (hasTestPlayers) {
        mockRankingData = {
          'TEST001': { rank: 1, moyenne: '2.098' },
          'TEST002': { rank: 2, moyenne: '2.057' },
          'TEST003': { rank: 3, moyenne: '1.985' },
          'TEST004': { rank: 4, moyenne: '1.876' },
          'TEST005': { rank: 5, moyenne: '1.754' },
          'TEST006': { rank: 6, moyenne: '1.698' },
          'TEST007': { rank: 7, moyenne: '1.623' },
          'TEST008': { rank: 8, moyenne: '1.567' },
          'TEST009': { rank: 9, moyenne: '1.498' },
          'TEST010': { rank: 10, moyenne: '1.432' },
          'TEST011': { rank: 11, moyenne: '1.387' },
          'TEST012': { rank: 12, moyenne: '1.298' }
        };
      }

      try {
        const response = await fetch(`${API_URL}/email/generate-summary-pdf`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            category: currentCategory,
            season: currentSeason,
            tournament: currentTournament,
            poules: poules,
            tournamentDate: matchingTournoi?.debut || null,
            locations: [
              location1 ? { ...location1, startTime: startTime1, locationNum: '1' } : null,
              location2 ? { ...location2, startTime: startTime2, locationNum: '2' } : null
            ].filter(Boolean),
            gameParams: currentGameParams,
            selectedDistance: selectedDistance,
            mockRankingData: mockRankingData,
            isFinale: isFinale
          })
        });

        if (response.ok) {
          const blob = await response.blob();
          const url = window.URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `Convocation_${currentCategory.display_name.replace(/\s+/g, '_')}_T${currentTournament}_${currentSeason}.pdf`;
          document.body.appendChild(a);
          a.click();
          a.remove();
          window.URL.revokeObjectURL(url);

          document.getElementById('successMessage').textContent = 'PDF r√©capitulatif t√©l√©charg√© !';
          document.getElementById('successMessage').style.display = 'block';
          setTimeout(() => {
            document.getElementById('successMessage').style.display = 'none';
          }, 3000);
        } else {
          const error = await response.json();
          document.getElementById('errorMessage').textContent = error.error || 'Erreur lors de la g√©n√©ration du PDF';
          document.getElementById('errorMessage').style.display = 'block';
        }
      } catch (error) {
        console.error('Error generating Summary PDF:', error);
        document.getElementById('errorMessage').textContent = 'Erreur lors de la g√©n√©ration du PDF';
        document.getElementById('errorMessage').style.display = 'block';
      }
    });

    // Last minute player search
    const lastMinuteSearch = document.getElementById('lastMinuteSearch');
    const lastMinuteResults = document.getElementById('lastMinuteResults');
    const addLastMinuteBtn = document.getElementById('addLastMinuteBtn');

    lastMinuteSearch.addEventListener('input', () => {
      const query = lastMinuteSearch.value.trim().toLowerCase();

      if (query.length < 2) {
        lastMinuteResults.style.display = 'none';
        selectedLastMinutePlayer = null;
        addLastMinuteBtn.disabled = true;
        return;
      }

      // Get already selected licences
      const selectedLicences = new Set([
        ...rankedPlayers.filter(p => p.selected).map(p => p.licence?.replace(/\s/g, '')),
        ...newPlayers.filter(p => p.selected).map(p => p.licence?.replace(/\s/g, '')),
        ...lastMinutePlayers.map(p => p.licence?.replace(/\s/g, ''))
      ]);

      // Search in all system players
      const results = allSystemPlayers
        .filter(p => {
          const fullName = `${p.last_name} ${p.first_name}`.toLowerCase();
          const licence = (p.licence || '').toLowerCase();
          return (fullName.includes(query) || licence.includes(query)) &&
                 !selectedLicences.has(p.licence?.replace(/\s/g, ''));
        })
        .slice(0, 10);

      if (results.length === 0) {
        lastMinuteResults.innerHTML = '<p style="padding: 10px; color: #666;">Aucun joueur trouv√©</p>';
        lastMinuteResults.style.display = 'block';
        return;
      }

      lastMinuteResults.innerHTML = results.map(p => `
        <div class="search-result-item" data-licence="${p.licence}"
             style="padding: 10px 15px; border-bottom: 1px solid #eee; cursor: pointer; transition: background 0.2s;">
          <strong>${p.last_name} ${p.first_name}</strong>
          <span style="color: #666; margin-left: 10px;">${p.club || ''}</span>
          <span style="color: #999; margin-left: 10px; font-size: 0.85em;">${p.licence}</span>
        </div>
      `).join('');

      lastMinuteResults.style.display = 'block';

      // Add click handlers to search results
      lastMinuteResults.querySelectorAll('.search-result-item').forEach(item => {
        item.addEventListener('mouseover', () => item.style.background = '#f5f5f5');
        item.addEventListener('mouseout', () => {
          if (selectedLastMinutePlayer?.licence !== item.dataset.licence) {
            item.style.background = '';
          }
        });
        item.addEventListener('click', () => {
          // Deselect previous
          lastMinuteResults.querySelectorAll('.search-result-item').forEach(i => i.style.background = '');

          // Select this one
          item.style.background = '#e3f2fd';
          selectedLastMinutePlayer = allSystemPlayers.find(p => p.licence === item.dataset.licence);
          addLastMinuteBtn.disabled = false;
        });
      });
    });

    // Get the rank field name for a game type
    function getRankFieldForGameType(gameType) {
      const mapping = {
        'LIBRE': 'rank_libre',
        '3BANDES': 'rank_3bandes',
        '3 BANDES': 'rank_3bandes',
        'BANDE': 'rank_bande',
        '1BANDE': 'rank_bande',
        '1 BANDE': 'rank_bande',
        'CADRE': 'rank_cadre'
      };
      return mapping[gameType.toUpperCase()] || 'rank_libre';
    }

    // Check if player's rank matches the tournament category
    function checkPlayerCategory(player, category) {
      if (!category) return { matches: true };

      const rankField = getRankFieldForGameType(category.game_type);
      const playerRank = player[rankField] || 'NC';
      const tournamentLevel = category.level.toUpperCase();

      // NC (Non Class√©) is considered not matching any specific level
      if (playerRank === 'NC' || playerRank.toUpperCase() === 'NC') {
        return {
          matches: false,
          playerRank: 'NC (Non Class√©)',
          expectedLevel: tournamentLevel,
          gameType: category.game_type
        };
      }

      // Check if ranks match
      const matches = playerRank.toUpperCase() === tournamentLevel;
      return {
        matches,
        playerRank: playerRank,
        expectedLevel: tournamentLevel,
        gameType: category.game_type
      };
    }

    addLastMinuteBtn.addEventListener('click', () => {
      if (!selectedLastMinutePlayer) return;

      // Check if player's category matches the tournament
      const categoryCheck = checkPlayerCategory(selectedLastMinutePlayer, currentCategory);

      if (!categoryCheck.matches) {
        const playerName = `${selectedLastMinutePlayer.first_name} ${selectedLastMinutePlayer.last_name}`;
        const message = `‚ö†Ô∏è Attention: ${playerName} a le classement "${categoryCheck.playerRank}" en ${categoryCheck.gameType}, mais ce tournoi est pour la cat√©gorie "${categoryCheck.expectedLevel}".\n\nVoulez-vous quand m√™me l'ajouter ?`;

        if (!confirm(message)) {
          return; // User cancelled, don't add the player
        }
      }

      // Add to last minute players
      lastMinutePlayers.push({
        licence: selectedLastMinutePlayer.licence,
        first_name: selectedLastMinutePlayer.first_name,
        last_name: selectedLastMinutePlayer.last_name,
        club: selectedLastMinutePlayer.club || '',
        isNew: true,
        isLastMinute: true,
        selected: true
      });

      // Reset search
      lastMinuteSearch.value = '';
      lastMinuteResults.style.display = 'none';
      selectedLastMinutePlayer = null;
      addLastMinuteBtn.disabled = true;

      renderPlayerLists();
    });

    // ==========================================
    // EMAIL CONVOCATIONS FUNCTIONALITY
    // ==========================================

    // Store player emails from inscriptions
    let playerEmails = {};
    let lastGeneratedData = null;

    // Update email stats and populate checkbox list when reaching step 4
    function updateEmailStats() {
      const checkboxList = document.getElementById('playerCheckboxList');
      checkboxList.innerHTML = '';

      let emailableCount = 0;
      const playersWithEmailInfo = selectedPlayers.map(p => {
        const email = p.email || playerEmails[p.licence?.replace(/\s/g, '')];
        const hasEmail = email && email.includes('@');
        if (hasEmail) emailableCount++;
        return { ...p, email, hasEmail };
      });

      // Sort: players with email first
      playersWithEmailInfo.sort((a, b) => {
        if (a.hasEmail && !b.hasEmail) return -1;
        if (!a.hasEmail && b.hasEmail) return 1;
        return (a.last_name || '').localeCompare(b.last_name || '');
      });

      // Create checkboxes for each player
      playersWithEmailInfo.forEach(p => {
        const div = document.createElement('div');
        div.style.cssText = 'display: flex; align-items: center; padding: 8px; border-bottom: 1px solid #eee;';
        div.id = `row_${p.licence?.replace(/\s/g, '')}`;

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `player_${p.licence?.replace(/\s/g, '')}`;
        checkbox.dataset.licence = p.licence?.replace(/\s/g, '');
        checkbox.checked = p.hasEmail; // Checked by default if has email
        checkbox.disabled = !p.hasEmail; // Disabled if no email
        checkbox.style.cssText = 'width: 18px; height: 18px; margin-right: 10px; cursor: pointer;';
        checkbox.addEventListener('change', updateCheckedCount);

        const label = document.createElement('label');
        label.htmlFor = checkbox.id;
        label.id = `label_${p.licence?.replace(/\s/g, '')}`;
        label.style.cssText = `flex: 1; cursor: pointer; ${!p.hasEmail ? 'color: #999;' : ''}`;
        label.innerHTML = `<strong>${p.last_name || ''} ${p.first_name || ''}</strong> - ${p.hasEmail ? p.email : '<em>Pas d\'email</em>'}`;

        // Edit button
        const editBtn = document.createElement('button');
        editBtn.type = 'button';
        editBtn.innerHTML = '‚úèÔ∏è';
        editBtn.title = 'Modifier l\'email';
        editBtn.style.cssText = 'background: none; border: none; cursor: pointer; font-size: 16px; padding: 4px 8px;';
        editBtn.onclick = () => showEmailEditor(p.licence?.replace(/\s/g, ''), p.last_name, p.first_name, p.email || '');

        div.appendChild(checkbox);
        div.appendChild(label);
        div.appendChild(editBtn);
        checkboxList.appendChild(div);
      });

      document.getElementById('emailableCount').textContent = emailableCount;
      document.getElementById('totalPlayersCount').textContent = selectedPlayers.length;
      updateCheckedCount();

      // Disable button if no emails
      document.getElementById('sendConvocationsBtn').disabled = emailableCount === 0;
    }

    // Update checked count display
    function updateCheckedCount() {
      const checkboxes = document.querySelectorAll('#playerCheckboxList input[type="checkbox"]:checked');
      document.getElementById('checkedCount').textContent = checkboxes.length;
      document.getElementById('sendConvocationsBtn').disabled = checkboxes.length === 0;
    }

    // Show email editor inline
    function showEmailEditor(licence, lastName, firstName, currentEmail) {
      const row = document.getElementById(`row_${licence}`);
      if (!row) return;

      // Replace row content with editor
      const originalContent = row.innerHTML;
      row.innerHTML = `
        <div style="flex: 1; display: flex; align-items: center; gap: 8px;">
          <strong>${lastName || ''} ${firstName || ''}</strong>
          <input type="email" id="emailInput_${licence}" value="${currentEmail}"
                 placeholder="email@exemple.com"
                 style="flex: 1; padding: 6px 10px; border: 1px solid #1F4788; border-radius: 4px; font-size: 14px;">
          <button type="button" onclick="saveEmail('${licence}', '${lastName}', '${firstName}')"
                  style="background: #28a745; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer;">
            ‚úì
          </button>
          <button type="button" onclick="cancelEmailEdit('${licence}')"
                  style="background: #dc3545; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer;">
            ‚úó
          </button>
        </div>
      `;
      row.dataset.originalContent = originalContent;

      // Focus the input
      setTimeout(() => {
        const input = document.getElementById(`emailInput_${licence}`);
        if (input) {
          input.focus();
          input.select();
        }
      }, 50);
    }

    // Save edited email
    function saveEmail(licence, lastName, firstName) {
      const input = document.getElementById(`emailInput_${licence}`);
      const newEmail = input?.value?.trim() || '';

      if (newEmail && !newEmail.includes('@')) {
        alert('Veuillez entrer un email valide');
        return;
      }

      // Store in playerEmails object (temporary for this session)
      if (newEmail) {
        playerEmails[licence] = newEmail;
      } else {
        delete playerEmails[licence];
      }

      // Update the row display
      const row = document.getElementById(`row_${licence}`);
      const hasEmail = newEmail && newEmail.includes('@');

      row.innerHTML = '';

      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.id = `player_${licence}`;
      checkbox.dataset.licence = licence;
      checkbox.checked = hasEmail;
      checkbox.disabled = !hasEmail;
      checkbox.style.cssText = 'width: 18px; height: 18px; margin-right: 10px; cursor: pointer;';
      checkbox.addEventListener('change', updateCheckedCount);

      const label = document.createElement('label');
      label.htmlFor = checkbox.id;
      label.id = `label_${licence}`;
      label.style.cssText = `flex: 1; cursor: pointer; ${!hasEmail ? 'color: #999;' : ''}`;
      label.innerHTML = `<strong>${lastName || ''} ${firstName || ''}</strong> - ${hasEmail ? newEmail : '<em>Pas d\'email</em>'}`;

      const editBtn = document.createElement('button');
      editBtn.type = 'button';
      editBtn.innerHTML = '‚úèÔ∏è';
      editBtn.title = 'Modifier l\'email';
      editBtn.style.cssText = 'background: none; border: none; cursor: pointer; font-size: 16px; padding: 4px 8px;';
      editBtn.onclick = () => showEmailEditor(licence, lastName, firstName, newEmail);

      row.appendChild(checkbox);
      row.appendChild(label);
      row.appendChild(editBtn);

      // Update counts
      updateEmailCounts();
      updateCheckedCount();
    }

    // Cancel email edit
    function cancelEmailEdit(licence) {
      const row = document.getElementById(`row_${licence}`);
      if (row && row.dataset.originalContent) {
        row.innerHTML = row.dataset.originalContent;
      } else {
        // Refresh the whole list
        updateEmailStats();
      }
    }

    // Update emailable count after edit
    function updateEmailCounts() {
      let emailableCount = 0;
      selectedPlayers.forEach(p => {
        const email = p.email || playerEmails[p.licence?.replace(/\s/g, '')];
        if (email && email.includes('@')) emailableCount++;
      });
      document.getElementById('emailableCount').textContent = emailableCount;
      document.getElementById('totalPlayersCount').textContent = selectedPlayers.length;
      document.getElementById('sendConvocationsBtn').disabled = emailableCount === 0;
    }

    // Select all / Deselect all buttons for email section
    document.getElementById('emailSelectAllBtn').addEventListener('click', () => {
      document.querySelectorAll('#playerCheckboxList input[type="checkbox"]:not(:disabled)').forEach(cb => cb.checked = true);
      updateCheckedCount();
    });

    document.getElementById('emailDeselectAllBtn').addEventListener('click', () => {
      document.querySelectorAll('#playerCheckboxList input[type="checkbox"]').forEach(cb => cb.checked = false);
      updateCheckedCount();
    });

    // Store the data used for generation so we can use it for emails
    function storeGenerationData(data) {
      lastGeneratedData = data;
    }

    // Test mode toggle
    document.getElementById('testModeCheckbox').addEventListener('change', (e) => {
      const isTestMode = e.target.checked;
      document.getElementById('testEmailContainer').style.display = isTestMode ? 'block' : 'none';
      document.getElementById('sendConvocationsBtn').style.display = isTestMode ? 'none' : '';
      document.getElementById('sendTestBtn').style.display = isTestMode ? '' : 'none';
    });

    // Send test convocation
    document.getElementById('sendTestBtn').addEventListener('click', async () => {
      if (!lastGeneratedData) {
        alert('Veuillez d\'abord g√©n√©rer le fichier Excel');
        return;
      }

      const testEmail = document.getElementById('testEmailInput').value.trim();
      if (!testEmail || !testEmail.includes('@')) {
        alert('Veuillez entrer une adresse email valide');
        return;
      }

      const btn = document.getElementById('sendTestBtn');
      const progress = document.getElementById('emailProgress');
      const progressBar = document.getElementById('emailProgressBar');
      const progressText = document.getElementById('emailProgressText');
      const results = document.getElementById('emailResults');

      // Get first checked player for test
      const firstChecked = document.querySelector('#playerCheckboxList input[type="checkbox"]:checked');
      if (!firstChecked) {
        alert('Veuillez s√©lectionner au moins un joueur pour le test');
        return;
      }

      const testLicence = firstChecked.dataset.licence;
      const testPlayer = selectedPlayers.find(p => p.licence?.replace(/\s/g, '') === testLicence);

      if (!testPlayer) {
        alert('Joueur non trouv√©');
        return;
      }

      // Disable button and show progress
      btn.disabled = true;
      btn.textContent = 'Envoi du test...';
      progress.style.display = 'block';
      results.style.display = 'none';
      progressBar.style.width = '50%';
      progressText.textContent = 'Envoi du test...';

      try {
        // Send ONE convocation to the test email
        const response = await fetch(`${API_URL}/email/send-convocations`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            players: [{ ...testPlayer, email: testEmail }],
            poules: lastGeneratedData.poules,
            category: currentCategory,
            season: currentSeason,
            tournament: currentTournament,
            tournamentDate: lastGeneratedData.tournamentDate,
            tournoiId: lastGeneratedData.tournoiId,
            locations: lastGeneratedData.locations,
            specialNote: document.getElementById('specialNoteField').value.trim(),
            gameParams: lastGeneratedData.gameParams,
            selectedDistance: lastGeneratedData.selectedDistance,
            isFinale: window.currentCompetitionIsFinale || false,
            isTestMode: true,
            skipSavePoules: true
          })
        });

        progressBar.style.width = '100%';
        const result = await response.json();

        if (response.ok && result.results.sent.length > 0) {
          progressText.textContent = `Test envoy√© avec succ√®s √† ${testEmail}`;
          progressText.style.color = '#28a745';
          results.style.display = 'block';
          results.innerHTML = `<div style="background: #d4edda; padding: 10px; border-radius: 4px;">
            <strong>‚úÖ Test envoy√©</strong><br>
            Convocation de <strong>${testPlayer.first_name} ${testPlayer.last_name}</strong> envoy√©e √† <strong>${testEmail}</strong>
          </div>`;
        } else {
          progressText.textContent = `Erreur: ${result.error || '√âchec de l\'envoi'}`;
          progressText.style.color = '#dc3545';
        }
      } catch (error) {
        console.error('Error sending test:', error);
        progressBar.style.width = '100%';
        progressText.textContent = `Erreur: ${error.message}`;
        progressText.style.color = '#dc3545';
      }

      btn.disabled = false;
      btn.textContent = 'üß™ Envoyer le Test';
    });

    // Send convocations
    document.getElementById('sendConvocationsBtn').addEventListener('click', async () => {
      if (!lastGeneratedData) {
        alert('Veuillez d\'abord g√©n√©rer le fichier Excel');
        return;
      }

      const btn = document.getElementById('sendConvocationsBtn');
      const progress = document.getElementById('emailProgress');
      const progressBar = document.getElementById('emailProgressBar');
      const progressText = document.getElementById('emailProgressText');
      const results = document.getElementById('emailResults');

      // Get selected players from checkboxes
      const checkedLicences = [];
      document.querySelectorAll('#playerCheckboxList input[type="checkbox"]:checked').forEach(cb => {
        checkedLicences.push(cb.dataset.licence);
      });

      if (checkedLicences.length === 0) {
        alert('Veuillez s√©lectionner au moins un joueur');
        return;
      }

      // Confirm
      if (!confirm(`Envoyer les convocations √† ${checkedLicences.length} joueur(s) s√©lectionn√©(s) ?`)) {
        return;
      }

      // Disable button and show progress
      btn.disabled = true;
      btn.textContent = 'Envoi en cours...';
      progress.style.display = 'block';
      results.style.display = 'none';
      progressBar.style.width = '10%';
      progressText.textContent = 'Pr√©paration des emails...';

      try {
        // Filter to only checked players and add emails
        const playersWithEmails = selectedPlayers
          .filter(p => checkedLicences.includes(p.licence?.replace(/\s/g, '')))
          .map(p => {
            const email = p.email || playerEmails[p.licence?.replace(/\s/g, '')];
            return { ...p, email };
          });

        progressBar.style.width = '30%';
        progressText.textContent = 'Envoi des convocations...';

        // Check if we have test players (TEST*) and inject mock ranking data for testing
        const hasTestPlayers = playersWithEmails.some(p => p.licence?.startsWith('TEST'));
        let mockRankingData = null;
        if (hasTestPlayers) {
          mockRankingData = {
            'TEST001': { rank: 1, moyenne: '2.098' },
            'TEST002': { rank: 2, moyenne: '2.057' },
            'TEST003': { rank: 3, moyenne: '2.697' },
            'TEST004': { rank: 4, moyenne: '1.856' },
            'TEST005': { rank: 5, moyenne: '1.542' },
            'TEST006': { rank: 6, moyenne: '1.234' }
          };
          console.log('Test players detected, using mock ranking data');
        }

        const response = await fetch(`${API_URL}/email/send-convocations`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            players: playersWithEmails,
            poules: lastGeneratedData.poules,
            category: currentCategory,
            season: currentSeason,
            tournament: currentTournament,
            tournamentDate: lastGeneratedData.tournamentDate,
            tournoiId: lastGeneratedData.tournoiId,
            locations: lastGeneratedData.locations,
            specialNote: document.getElementById('specialNoteField').value.trim(),
            gameParams: lastGeneratedData.gameParams,
            selectedDistance: lastGeneratedData.selectedDistance,
            mockRankingData: mockRankingData,
            isFinale: window.currentCompetitionIsFinale || false
          })
        });

        progressBar.style.width = '100%';

        const result = await response.json();

        if (response.ok) {
          progressText.textContent = `Emails envoy√©s: ${result.results.sent.length}, √âchecs: ${result.results.failed.length}, Ignor√©s: ${result.results.skipped.length}`;
          progressText.style.color = '#28a745';

          // Show results
          results.style.display = 'block';
          results.innerHTML = '';

          if (result.results.sent.length > 0) {
            results.innerHTML += `<div style="background: #d4edda; padding: 10px; border-radius: 4px; margin-bottom: 10px;">
              <strong>‚úÖ Envoy√©s (${result.results.sent.length}):</strong>
              <ul style="margin: 5px 0 0 20px;">${result.results.sent.map(s => `<li>${s.name} - ${s.email}</li>`).join('')}</ul>
            </div>`;
          }

          if (result.results.failed.length > 0) {
            results.innerHTML += `<div style="background: #f8d7da; padding: 10px; border-radius: 4px; margin-bottom: 10px;">
              <strong>‚ùå √âchecs (${result.results.failed.length}):</strong>
              <ul style="margin: 5px 0 0 20px;">${result.results.failed.map(f => `<li>${f.name} - ${f.error}</li>`).join('')}</ul>
            </div>`;
          }

          if (result.results.skipped.length > 0) {
            results.innerHTML += `<div style="background: #fff3cd; padding: 10px; border-radius: 4px;">
              <strong>‚ö†Ô∏è Ignor√©s (${result.results.skipped.length}):</strong>
              <ul style="margin: 5px 0 0 20px;">${result.results.skipped.map(s => `<li>${s.name} - ${s.reason}</li>`).join('')}</ul>
            </div>`;
          }

          // Send club reminders if convocations were sent successfully
          // Skip if this is a resend (forfait) - club was already notified
          if (result.results.sent.length > 0 && lastGeneratedData.locations && !lastGeneratedData.skipClubReminders) {
            await sendClubReminders(lastGeneratedData, playersWithEmails.length);
          }
        } else {
          progressText.textContent = `Erreur: ${result.error}`;
          progressText.style.color = '#dc3545';
        }
      } catch (error) {
        console.error('Error sending emails:', error);
        progressBar.style.width = '100%';
        progressText.textContent = `Erreur: ${error.message}`;
        progressText.style.color = '#dc3545';
      }

      // Re-enable button
      btn.disabled = false;
      btn.textContent = '‚úâÔ∏è Envoyer les convocations';
    });

    // Save poules without sending emails
    document.getElementById('savePoulesOnlyBtn').addEventListener('click', async () => {
      if (!lastGeneratedData) {
        alert('Veuillez d\'abord g√©n√©rer le fichier Excel');
        return;
      }

      if (!lastGeneratedData.tournoiId) {
        alert('Impossible de sauvegarder: ID du tournoi manquant');
        return;
      }

      const btn = document.getElementById('savePoulesOnlyBtn');
      const resultDiv = document.getElementById('savePoulesResult');

      // Confirm
      if (!confirm(`Sauvegarder la composition des ${lastGeneratedData.poules.length} poule(s) sans envoyer d'emails ?`)) {
        return;
      }

      btn.disabled = true;
      btn.textContent = 'Sauvegarde...';
      resultDiv.style.display = 'none';

      try {
        const response = await fetch(`${API_URL}/email/save-poules`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            tournoiId: lastGeneratedData.tournoiId,
            poules: lastGeneratedData.poules,
            locations: lastGeneratedData.locations || []
          })
        });

        const result = await response.json();

        if (response.ok && result.success) {
          resultDiv.style.background = '#d4edda';
          resultDiv.style.color = '#155724';
          resultDiv.innerHTML = `‚úÖ ${result.message}`;
        } else {
          resultDiv.style.background = '#f8d7da';
          resultDiv.style.color = '#721c24';
          resultDiv.innerHTML = `‚ùå Erreur: ${result.error || 'Erreur inconnue'}`;
        }
      } catch (error) {
        console.error('Error saving poules:', error);
        resultDiv.style.background = '#f8d7da';
        resultDiv.style.color = '#721c24';
        resultDiv.innerHTML = `‚ùå Erreur: ${error.message}`;
      }

      resultDiv.style.display = 'block';
      btn.disabled = false;
      btn.textContent = 'üíæ Sauvegarder les poules (sans email)';
    });

    // Send club reminders to hosting clubs
    async function sendClubReminders(generatedData, totalPlayers) {
      const locations = generatedData.locations || [];
      const poules = generatedData.poules || [];
      const clubReminderResults = [];

      // Group poules by location to calculate players/tables per location
      const locationData = {};
      locations.forEach(loc => {
        locationData[loc.locationNum || '1'] = {
          name: loc.name,
          startTime: loc.startTime,
          players: 0,
          tables: 0
        };
      });

      // Count players per location from poules
      poules.forEach(poule => {
        const locNum = poule.locationNum || '1';
        if (locationData[locNum]) {
          locationData[locNum].players += poule.players.length;
        }
      });

      // Calculate tables per location based on player count
      for (const locNum in locationData) {
        const loc = locationData[locNum];
        loc.tables = calculateTablesNeeded(loc.players);
      }

      // Send reminder to each location
      for (const locNum in locationData) {
        const loc = locationData[locNum];
        if (!loc.name) continue;

        try {
          const response = await fetch(`${API_URL}/email/send-club-reminder`, {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${token}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              clubName: loc.name,
              category: currentCategory.display_name,
              tournament: currentTournament,
              tournamentDate: generatedData.tournamentDate,
              tournoiId: generatedData.tournoiId,
              startTime: loc.startTime || '14H00',
              numPlayers: loc.players,
              numTables: loc.tables,
              ccEmail: 'cdbhs92@gmail.com'
            })
          });

          const result = await response.json();
          clubReminderResults.push({
            club: loc.name,
            success: result.success,
            skipped: result.skipped,
            message: result.message
          });

          if (result.success) {
            console.log(`[Club Reminder] Sent to ${loc.name}`);
          } else if (result.skipped) {
            console.log(`[Club Reminder] Skipped ${loc.name}: ${result.message}`);
          }
        } catch (error) {
          console.error(`[Club Reminder] Error for ${loc.name}:`, error);
          clubReminderResults.push({
            club: loc.name,
            success: false,
            message: error.message
          });
        }
      }

      // Show club reminder results
      const resultsDiv = document.getElementById('emailResults');
      if (clubReminderResults.length > 0) {
        const sent = clubReminderResults.filter(r => r.success);
        const skipped = clubReminderResults.filter(r => r.skipped);

        let clubHtml = '<div style="background: #e7f3ff; padding: 10px; border-radius: 4px; margin-top: 10px;">';
        clubHtml += '<strong>üìß Rappels aux clubs:</strong><ul style="margin: 5px 0 0 20px;">';

        if (sent.length > 0) {
          clubHtml += sent.map(r => `<li style="color: #28a745;">‚úì ${r.club}</li>`).join('');
        }
        if (skipped.length > 0) {
          clubHtml += skipped.map(r => `<li style="color: #856404;">‚ö† ${r.club} - ${r.message}</li>`).join('');
        }

        clubHtml += '</ul></div>';
        resultsDiv.innerHTML += clubHtml;
      }
    }

    // Calculate number of tables needed based on player count
    // Poule of 3 = 1 table, poule of 4-5 = 2 tables
    function calculateTablesNeeded(numPlayers) {
      if (numPlayers < 3) return 0;
      if (numPlayers === 3) return 1;  // 1 poule of 3 = 1 table
      if (numPlayers <= 5) return 2;   // 1 poule of 4-5 = 2 tables
      if (numPlayers <= 6) return 2;   // 2 poules of 3 = 2 tables
      if (numPlayers <= 8) return 4;   // 2 poules of 4 = 4 tables
      if (numPlayers <= 9) return 3;   // 3 poules of 3 = 3 tables
      if (numPlayers <= 12) return 4;  // mixed poules
      if (numPlayers <= 15) return 5;
      if (numPlayers <= 18) return 6;
      // For more players, estimate based on poules
      return Math.ceil(numPlayers / 3);
    }

    // Fetch player emails from inscriptions when loading
    async function fetchPlayerEmails(tournoiId) {
      try {
        const response = await fetch(`${API_URL}/inscriptions/tournoi/${tournoiId}/inscriptions`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        if (response.ok) {
          const inscriptions = await response.json();
          inscriptions.forEach(i => {
            if (i.licence && i.email) {
              playerEmails[i.licence.replace(/\s/g, '')] = i.email;
            }
          });
        }
      } catch (error) {
        console.error('Error fetching player emails:', error);
      }
    }

    // ==================== POULE SIMULATION ====================

    async function openSimulationModal(tournoiId) {
      const modal = document.getElementById('simulationModal');
      const content = document.getElementById('simulationContent');
      const title = document.getElementById('simulationTitle');

      modal.style.display = 'flex';
      content.innerHTML = '<div class="spinner" style="margin: 40px auto;"></div>';
      title.textContent = 'Chargement...';

      try {
        const response = await fetch(`${API_URL}/inscriptions/tournoi/${tournoiId}/simulation`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });

        const data = await response.json();

        if (!data.available) {
          content.innerHTML = `
            <div style="text-align: center; padding: 40px;">
              <div style="font-size: 3rem; margin-bottom: 16px;">${data.reason === 'simulation_disabled' ? 'üîí' : 'üë•'}</div>
              <p style="color: #666;">${data.message}</p>
            </div>
          `;
          title.textContent = 'Simulation non disponible';
          return;
        }

        title.textContent = `${data.tournament.nom} - ${data.tournament.mode} ${data.tournament.categorie}`;

        let html = `
          <div style="text-align: center; margin-bottom: 20px;">
            <span style="background: #e3f2fd; color: #1565c0; padding: 8px 16px; border-radius: 20px; font-size: 14px; font-weight: 600;">
              ${data.simulation.player_count} joueurs ‚Ä¢ ${data.simulation.config_description}
            </span>
          </div>
          <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 16px;">
        `;

        data.simulation.poules.forEach(poule => {
          html += `
            <div style="background: #f8f9fa; border-radius: 8px; overflow: hidden; border: 1px solid #e9ecef;">
              <div style="background: #1F4788; color: white; padding: 10px 16px; font-weight: 600;">
                Poule ${poule.number}
              </div>
              <table style="width: 100%; border-collapse: collapse;">
                <thead>
                  <tr style="background: #e9ecef;">
                    <th style="padding: 8px; text-align: center; width: 40px;">#</th>
                    <th style="padding: 8px; text-align: left;">Joueur</th>
                    <th style="padding: 8px; text-align: center;">Class.</th>
                  </tr>
                </thead>
                <tbody>
                  ${poule.players.map((player, idx) => `
                    <tr style="border-bottom: 1px solid #e9ecef;">
                      <td style="padding: 8px; text-align: center;">
                        <span style="display: inline-block; width: 24px; height: 24px; background: ${idx === 0 ? '#ffc107' : '#e9ecef'}; color: ${idx === 0 ? '#000' : '#666'}; border-radius: 50%; line-height: 24px; font-size: 12px; font-weight: 600;">
                          ${player.seed}
                        </span>
                      </td>
                      <td style="padding: 8px;">
                        <div style="font-weight: 500;">${player.first_name} ${player.last_name}</div>
                        <div style="font-size: 11px; color: #666;">${player.club || '-'}</div>
                      </td>
                      <td style="padding: 8px; text-align: center;">
                        <span style="background: #e8f5e9; color: #2e7d32; padding: 3px 8px; border-radius: 10px; font-size: 11px; font-weight: 600;">
                          ${player.rank_display}
                        </span>
                      </td>
                    </tr>
                  `).join('')}
                </tbody>
              </table>
            </div>
          `;
        });

        html += `</div>
          <div style="text-align: center; margin-top: 20px; padding-top: 16px; border-top: 1px solid #eee;">
            <p style="font-size: 12px; color: #666;">
              Simulation g√©n√©r√©e le ${new Date(data.simulation.generated_at).toLocaleString('fr-FR')}
            </p>
          </div>
        `;

        content.innerHTML = html;

      } catch (error) {
        console.error('Simulation error:', error);
        content.innerHTML = `
          <div style="text-align: center; padding: 40px;">
            <div style="font-size: 3rem; margin-bottom: 16px;">‚ùå</div>
            <p style="color: #dc3545;">Erreur lors du chargement de la simulation</p>
          </div>
        `;
      }
    }

    function closeSimulationModal() {
      document.getElementById('simulationModal').style.display = 'none';
    }

    // ==================== FORFAIT MANAGEMENT ====================
    let forfaitSelectedTournoi = null;
    let forfaitSelectedPlayers = new Set();
    let forfaitCurrentPoules = [];
    let forfaitReplacementPlayer = null;
    let forfaitPreviewData = null;
    let forfaitTournamentData = null; // Store tournament info for transition to Step 3
    let cameFromForfait = false; // Track if we came from forfait management to Step 3

    // Open forfait management modal - setup when DOM ready
    function setupForfaitListeners() {
      const openBtn = document.getElementById('openForfaitManager');
      if (openBtn) openBtn.addEventListener('click', openForfaitModal);

      const categorySelect = document.getElementById('forfaitCategorySelect');
      if (categorySelect) {
        categorySelect.addEventListener('change', async (e) => {
          const [mode, categorie] = (e.target.value || '').split('|');
          if (mode && categorie) {
            await loadForfaitCompetitions(mode, categorie);
          } else {
            document.getElementById('forfaitCompetitionSelect').innerHTML = '<option value="">S√©lectionnez une cat√©gorie</option>';
            document.getElementById('forfaitPoulesContainer').style.display = 'none';
            document.getElementById('forfaitTournamentInfo').style.display = 'none';
            document.getElementById('forfaitActions').style.display = 'none';
          }
        });
      }

      const competitionSelect = document.getElementById('forfaitCompetitionSelect');
      if (competitionSelect) {
        competitionSelect.addEventListener('change', async (e) => {
          const tournoiId = e.target.value;
          if (!tournoiId) return;

          forfaitSelectedTournoi = tournoiId;
          forfaitSelectedPlayers.clear();
          forfaitReplacementPlayer = null;

          // Load poules for this tournament
          document.getElementById('forfaitLoading').style.display = 'block';
          document.getElementById('forfaitPoulesContainer').style.display = 'none';
          document.getElementById('forfaitNoPoules').style.display = 'none';
          document.getElementById('forfaitTournamentInfo').style.display = 'none';
          document.getElementById('forfaitActions').style.display = 'none';

          await loadForfaitPoules(tournoiId);
        });
      }

      const replacementSearch = document.getElementById('replacementSearch');
      if (replacementSearch) {
        replacementSearch.addEventListener('input', handleReplacementSearch);
      }
    }

    // Call setup after DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', setupForfaitListeners);
    } else {
      // DOM already loaded, setup immediately but defer to ensure elements exist
      setTimeout(setupForfaitListeners, 0);
    }

    async function openForfaitModal() {
      document.getElementById('forfaitModal').style.display = 'flex';
      forfaitSelectedPlayers.clear();
      forfaitReplacementPlayer = null;
      updateForfaitSummary();

      // Load categories
      await loadForfaitCategories();
    }

    function closeForfaitModal() {
      document.getElementById('forfaitModal').style.display = 'none';
    }

    async function loadForfaitCategories() {
      const categorySelect = document.getElementById('forfaitCategorySelect');
      const competitionSelect = document.getElementById('forfaitCompetitionSelect');

      try {
        // First, load upcoming tournaments with poules to get categories
        const response = await fetch(`${API_URL}/email/poules/upcoming`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });

        if (!response.ok) throw new Error('Failed to load tournaments');
        const tournaments = await response.json();

        if (tournaments.length === 0) {
          categorySelect.innerHTML = '<option value="">Aucune comp√©tition avec poules</option>';
          competitionSelect.innerHTML = '<option value="">-</option>';
          document.getElementById('forfaitNoPoules').style.display = 'block';
          document.getElementById('forfaitPoulesContainer').style.display = 'none';
          document.getElementById('forfaitTournamentInfo').style.display = 'none';
          document.getElementById('forfaitActions').style.display = 'none';
          return;
        }

        // Extract unique categories
        const categories = [...new Map(tournaments.map(t => [`${t.mode}|${t.categorie}`, t])).values()];

        categorySelect.innerHTML = '<option value="">S√©lectionnez une cat√©gorie</option>';
        categories.forEach(cat => {
          const option = document.createElement('option');
          option.value = `${cat.mode}|${cat.categorie}`;
          option.textContent = `${cat.mode} - ${cat.categorie}`;
          categorySelect.appendChild(option);
        });

        // Auto-select first category and load its competitions
        if (categories.length > 0) {
          categorySelect.value = `${categories[0].mode}|${categories[0].categorie}`;
          await loadForfaitCompetitions(categories[0].mode, categories[0].categorie, tournaments);
        }
      } catch (error) {
        console.error('Error loading forfait categories:', error);
        categorySelect.innerHTML = '<option value="">Erreur de chargement</option>';
      }
    }

    async function loadForfaitCompetitions(mode, categorie, cachedTournaments = null) {
      const competitionSelect = document.getElementById('forfaitCompetitionSelect');
      competitionSelect.innerHTML = '<option value="">Chargement...</option>';

      try {
        let tournaments = cachedTournaments;
        if (!tournaments) {
          const response = await fetch(`${API_URL}/email/poules/by-category?mode=${encodeURIComponent(mode)}&categorie=${encodeURIComponent(categorie)}`, {
            headers: { 'Authorization': `Bearer ${token}` }
          });
          if (!response.ok) throw new Error('Failed to load competitions');
          tournaments = await response.json();
        } else {
          tournaments = tournaments.filter(t =>
            t.mode?.toUpperCase() === mode.toUpperCase() &&
            t.categorie?.toUpperCase() === categorie.toUpperCase()
          );
        }

        if (tournaments.length === 0) {
          competitionSelect.innerHTML = '<option value="">Aucune comp√©tition</option>';
          return;
        }

        competitionSelect.innerHTML = '';
        tournaments.forEach(t => {
          const option = document.createElement('option');
          option.value = t.tournoi_id;
          const dateStr = t.tournament_date ? new Date(t.tournament_date).toLocaleDateString('fr-FR', { weekday: 'short', day: 'numeric', month: 'short' }) : '';
          option.textContent = `${t.tournament_name} - ${dateStr} (${t.player_count} joueurs)`;
          option.dataset.tournament = JSON.stringify(t);
          competitionSelect.appendChild(option);
        });

        // Auto-select first competition and load poules
        if (tournaments.length > 0) {
          competitionSelect.value = tournaments[0].tournoi_id;
          await loadForfaitPoules(tournaments[0].tournoi_id);
        }
      } catch (error) {
        console.error('Error loading forfait competitions:', error);
        competitionSelect.innerHTML = '<option value="">Erreur de chargement</option>';
      }
    }

    async function loadForfaitPoules(tournoiId) {
      forfaitSelectedTournoi = tournoiId;
      forfaitSelectedPlayers.clear();
      forfaitReplacementPlayer = null;
      updateForfaitSummary();

      document.getElementById('forfaitLoading').style.display = 'block';
      document.getElementById('forfaitPoulesContainer').style.display = 'none';
      document.getElementById('forfaitNoPoules').style.display = 'none';
      document.getElementById('forfaitTournamentInfo').style.display = 'none';
      document.getElementById('forfaitActions').style.display = 'none';
      document.getElementById('forfaitPlayersSection').style.display = 'none';

      try {
        const response = await fetch(`${API_URL}/email/poules/${tournoiId}`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });

        if (!response.ok) throw new Error('Failed to load poules');
        const data = await response.json();

        document.getElementById('forfaitLoading').style.display = 'none';

        if (!data.poules || data.poules.length === 0) {
          document.getElementById('forfaitNoPoules').style.display = 'block';
          // Still load forfait players even if no poules
          await loadForfaitPlayers(tournoiId);
          return;
        }

        forfaitCurrentPoules = data.poules;
        forfaitTournamentData = data.tournament; // Store for later use

        // Display tournament info
        const t = data.tournament;
        document.getElementById('forfaitTournamentName').textContent = `${t.mode} ${t.categorie} - ${t.nom}`;
        document.getElementById('forfaitTournamentDate').textContent = t.debut ? new Date(t.debut).toLocaleDateString('fr-FR', { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric' }) : '';
        document.getElementById('forfaitTournamentLieu').textContent = t.lieu || 'Lieu non d√©fini';

        const totalPlayers = data.poules.reduce((sum, p) => sum + p.players.length, 0);
        document.getElementById('forfaitPlayerCount').textContent = `${totalPlayers} joueur(s) - ${data.poules.length} poule(s)`;
        document.getElementById('forfaitTournamentInfo').style.display = 'block';

        // Render poules
        renderForfaitPoules(data.poules);
        document.getElementById('forfaitPoulesContainer').style.display = 'block';
        document.getElementById('forfaitActions').style.display = 'block';

        // Also load forfait players from inscriptions
        await loadForfaitPlayers(tournoiId);
      } catch (error) {
        console.error('Error loading forfait poules:', error);
        document.getElementById('forfaitLoading').style.display = 'none';
        document.getElementById('forfaitNoPoules').style.display = 'block';
      }
    }

    // Load players marked as forfait in inscriptions
    async function loadForfaitPlayers(tournoiId) {
      try {
        const response = await fetch(`${API_URL}/inscriptions?tournoi_id=${tournoiId}`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });

        if (!response.ok) return;

        const data = await response.json();
        const inscriptions = Array.isArray(data) ? data : (data.inscriptions || []);

        // Filter to get only forfait players
        const forfaitPlayers = inscriptions.filter(i => i.forfait === 1);

        const section = document.getElementById('forfaitPlayersSection');
        const countEl = document.getElementById('forfaitPlayersCount');
        const listEl = document.getElementById('forfaitPlayersList');

        if (forfaitPlayers.length === 0) {
          section.style.display = 'none';
          return;
        }

        countEl.textContent = forfaitPlayers.length;
        listEl.innerHTML = forfaitPlayers.map(player => `
          <div class="forfait-player-item" style="display: flex; justify-content: space-between; align-items: center; padding: 10px 12px; background: white; border-radius: 6px; border: 1px solid #ffc107;">
            <div>
              <div style="font-weight: 600; color: #333;">${player.first_name || ''} ${player.last_name || ''}</div>
              <div style="font-size: 12px; color: #666;">${player.club || ''} ‚Ä¢ ${player.licence}</div>
            </div>
            <button class="btn" style="background: #28a745; color: white; padding: 6px 12px; font-size: 12px;"
                    onclick="reintegratePlayer(${player.inscription_id}, '${(player.first_name || '').replace(/'/g, "\\'")} ${(player.last_name || '').replace(/'/g, "\\'")}')">
              R√©int√©grer
            </button>
          </div>
        `).join('');

        section.style.display = 'block';
      } catch (error) {
        console.error('Error loading forfait players:', error);
      }
    }

    // Reintegrate a forfait player
    async function reintegratePlayer(inscriptionId, playerName) {
      if (!confirm(`R√©int√©grer ${playerName} dans la liste des inscrits ?`)) {
        return;
      }

      try {
        const response = await fetch(`${API_URL}/inscriptions/${inscriptionId}/reintegrate`, {
          method: 'PUT',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          }
        });

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Erreur lors de la r√©int√©gration');
        }

        // Reset UI state - close preview if open, show normal view
        document.getElementById('forfaitPreview').style.display = 'none';
        document.getElementById('forfaitPoulesContainer').style.display = 'block';
        document.getElementById('forfaitActions').style.display = 'block';
        forfaitPreviewData = null;

        // Reload forfait players list
        await loadForfaitPlayers(forfaitSelectedTournoi);

        alert(`${playerName} a √©t√© r√©int√©gr√©.\n\nCliquez sur "R√©g√©n√©rer les poules" pour l'inclure dans les nouvelles poules.`);
      } catch (error) {
        console.error('Error reintegrating player:', error);
        alert('Erreur: ' + error.message);
      }
    }

    function renderForfaitPoules(poules) {
      const container = document.getElementById('forfaitPoulesList');
      container.innerHTML = poules.map(poule => `
        <div class="forfait-poule" style="background: white; border: 1px solid #ddd; border-radius: 8px; overflow: hidden;">
          <div style="background: #1F4788; color: white; padding: 10px 15px; font-weight: bold;">
            Poule ${poule.number}
            <span style="font-weight: normal; font-size: 12px; opacity: 0.8;">${poule.location_name || ''} - ${poule.start_time || ''}</span>
          </div>
          <div style="padding: 10px;">
            ${poule.players.map(player => `
              <div class="forfait-player ${player.isForfait ? 'is-forfait' : ''} ${forfaitSelectedPlayers.has(player.licence) ? 'selected-forfait' : ''}"
                   data-licence="${player.licence}"
                   data-name="${player.player_name}"
                   onclick="toggleForfaitPlayer('${player.licence}', '${player.player_name?.replace(/'/g, "\\'")}')"
                   style="display: flex; justify-content: space-between; align-items: center; padding: 8px 10px; margin: 4px 0; border-radius: 4px; cursor: pointer;
                          background: ${player.isForfait ? '#ffebee' : forfaitSelectedPlayers.has(player.licence) ? '#fff3cd' : '#f8f9fa'};
                          border-left: 3px solid ${player.isForfait ? '#dc3545' : forfaitSelectedPlayers.has(player.licence) ? '#ffc107' : 'transparent'};">
                <div>
                  <div style="font-weight: 500; ${player.isForfait ? 'text-decoration: line-through; color: #999;' : ''}">${player.player_name}</div>
                  <div style="font-size: 11px; color: #666;">${player.club || ''}</div>
                </div>
                <div>
                  ${player.isForfait ? '<span style="background: #dc3545; color: white; padding: 2px 6px; border-radius: 4px; font-size: 10px;">FORFAIT</span>' : ''}
                  ${forfaitSelectedPlayers.has(player.licence) && !player.isForfait ? '<span style="background: #ffc107; color: #333; padding: 2px 6px; border-radius: 4px; font-size: 10px;">√Ä RETIRER</span>' : ''}
                </div>
              </div>
            `).join('')}
          </div>
        </div>
      `).join('');
    }

    function toggleForfaitPlayer(licence, name) {
      // Check if already a confirmed forfait
      const isAlreadyForfait = forfaitCurrentPoules.some(p => p.players.some(pl => pl.licence === licence && pl.isForfait));
      if (isAlreadyForfait) return; // Can't toggle confirmed forfaits

      if (forfaitSelectedPlayers.has(licence)) {
        forfaitSelectedPlayers.delete(licence);
      } else {
        forfaitSelectedPlayers.add(licence);
      }
      renderForfaitPoules(forfaitCurrentPoules);
      updateForfaitSummary();
    }

    function updateForfaitSummary() {
      const summary = document.getElementById('forfaitSummary');
      const list = document.getElementById('forfaitList');
      const regenBtn = document.getElementById('regeneratePoulesBtn');

      // Always enable button (allow regeneration to reintegrate players)
      if (regenBtn) regenBtn.disabled = false;

      if (forfaitSelectedPlayers.size > 0) {
        const names = [];
        forfaitCurrentPoules.forEach(p => {
          p.players.forEach(pl => {
            if (forfaitSelectedPlayers.has(pl.licence)) {
              names.push(pl.player_name);
            }
          });
        });
        if (list) list.textContent = names.join(', ');
        if (summary) summary.style.display = 'block';
      } else {
        if (summary) summary.style.display = 'none';
      }
      // Close any open preview when selection changes
      closePreview();
    }

    async function previewPoules() {
      console.log('previewPoules called', {
        forfaitSelectedTournoi,
        forfaitSelectedPlayers: Array.from(forfaitSelectedPlayers),
        forfaitReplacementPlayer
      });

      // Allow regeneration even without selecting forfait (to reintegrate reinstated players)

      const btn = document.getElementById('regeneratePoulesBtn');
      if (btn) {
        btn.disabled = true;
        btn.textContent = 'Chargement...';
      }

      try {
        console.log('Making API call to:', `${API_URL}/email/poules/${forfaitSelectedTournoi}/regenerate`);
        const response = await fetch(`${API_URL}/email/poules/${forfaitSelectedTournoi}/regenerate`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            forfaitLicences: Array.from(forfaitSelectedPlayers),
            replacementPlayer: forfaitReplacementPlayer,
            previewOnly: true
          })
        });

        console.log('Response status:', response.status);

        if (!response.ok) {
          const error = await response.json();
          console.error('API error:', error);
          throw new Error(error.error || 'Failed to preview poules');
        }

        forfaitPreviewData = await response.json();
        console.log('Preview data received:', forfaitPreviewData);

        // Hide current poules, show preview in its place
        const poulesContainer = document.getElementById('forfaitPoulesContainer');
        const previewEl = document.getElementById('forfaitPreview');
        const actionsEl = document.getElementById('forfaitActions');

        if (poulesContainer) poulesContainer.style.display = 'none';
        if (actionsEl) actionsEl.style.display = 'none';

        renderPreview(forfaitPreviewData);
        if (previewEl) {
          previewEl.style.display = 'block';
          // Scroll to top of modal content
          const modalContent = previewEl.closest('.modal-content');
          if (modalContent) modalContent.scrollTop = 0;
        }

      } catch (error) {
        console.error('Error previewing poules:', error);
        alert('Erreur: ' + error.message);
      } finally {
        if (btn) {
          btn.disabled = false;
          btn.textContent = 'üîÑ R√©g√©n√©rer les poules';
        }
      }
    }

    function renderPreview(data) {
      const container = document.getElementById('forfaitPreviewPoules');
      container.innerHTML = data.poules.map(poule => `
        <div style="background: white; border: 1px solid #ddd; border-radius: 6px; overflow: hidden;">
          <div style="background: #17a2b8; color: white; padding: 8px 12px; font-weight: bold; font-size: 13px;">
            Poule ${poule.number}
          </div>
          <div style="padding: 8px;">
            ${poule.players.map(player => `
              <div style="padding: 6px 8px; border-bottom: 1px solid #eee; font-size: 12px;
                          ${player.isNouveau ? 'background: #fff3e0;' : ''}">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                  <span style="font-weight: 500;">${player.name}</span>
                  ${player.rank ? `<span style="background: #1F4788; color: white; padding: 1px 6px; border-radius: 10px; font-size: 10px;">#${player.rank}</span>` : '<span style="background: #ff9800; color: white; padding: 1px 6px; border-radius: 10px; font-size: 10px;">Nouv.</span>'}
                </div>
                <div style="color: #666; font-size: 11px;">${player.club || ''}</div>
              </div>
            `).join('')}
          </div>
        </div>
      `).join('');
    }

    function closePreview() {
      // Hide preview, restore original poules view
      const previewEl = document.getElementById('forfaitPreview');
      const poulesContainer = document.getElementById('forfaitPoulesContainer');
      const actionsEl = document.getElementById('forfaitActions');

      if (previewEl) previewEl.style.display = 'none';
      if (poulesContainer) poulesContainer.style.display = 'block';
      if (actionsEl) actionsEl.style.display = 'block';

      forfaitPreviewData = null;
    }

    async function confirmRegeneration() {
      if (!forfaitPreviewData) {
        alert('Veuillez d\'abord pr√©visualiser les poules');
        return;
      }

      const btn = document.querySelector('#forfaitPreview button[onclick="confirmRegeneration()"]');
      btn.disabled = true;
      btn.textContent = 'Enregistrement...';

      try {
        const response = await fetch(`${API_URL}/email/poules/${forfaitSelectedTournoi}/regenerate`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            forfaitLicences: Array.from(forfaitSelectedPlayers),
            replacementPlayer: forfaitReplacementPlayer,
            previewOnly: false
          })
        });

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Failed to regenerate poules');
        }

        const result = await response.json();

        // Transition to Step 3 instead of staying in forfait modal
        await transitionToStep3(result);

      } catch (error) {
        console.error('Error regenerating poules:', error);
        alert('Erreur: ' + error.message);
        btn.disabled = false;
        btn.textContent = '‚úì Confirmer et enregistrer';
      }
    }

    // Transition from forfait management to Step 3 (convocation flow)
    async function transitionToStep3(regenerateResult) {
      // Mark that we came from forfait management
      cameFromForfait = true;

      const t = forfaitTournamentData;
      if (!t) {
        alert('Erreur: donn√©es du tournoi manquantes');
        return;
      }

      // Fetch inscriptions to get player emails BEFORE closing modal
      try {
        const inscResponse = await fetch(`${API_URL}/inscriptions?tournoi_id=${forfaitSelectedTournoi}`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        if (inscResponse.ok) {
          const inscData = await inscResponse.json();
          playerEmails = {};
          const inscriptions = Array.isArray(inscData) ? inscData : (inscData.inscriptions || []);
          inscriptions.forEach(insc => {
            const cleanLicence = insc.licence?.replace(/\s/g, '');
            if (cleanLicence && insc.email) {
              playerEmails[cleanLicence] = insc.email;
            }
          });
        }
      } catch (e) {
        console.error('Error loading inscriptions for emails:', e);
      }

      // Close forfait modal
      closeForfaitModal();

      // Reset forfait state
      forfaitSelectedPlayers.clear();
      forfaitReplacementPlayer = null;
      forfaitPreviewData = null;

      // Set up global variables for Step 3
      // Extract tournament number from nom (e.g., "Tournoi 3" -> "3")
      const tournamentNumMatch = t.nom?.match(/(\d+)/);
      currentTournament = tournamentNumMatch ? tournamentNumMatch[1] : '1';

      // Set up category
      currentCategory = {
        display_name: `${t.mode} - ${t.categorie}`,
        game_type: t.mode,
        level: t.categorie
      };

      // Set up matchingTournoi for date/lieu display
      matchingTournoi = {
        tournoi_id: forfaitSelectedTournoi,
        nom: t.nom,
        debut: t.debut,
        lieu: t.lieu
      };

      // Build selectedPlayers from regenerate result
      // Include first_name, last_name, and email (needed by updateEmailStats in Step 4)
      selectedPlayers = [];
      let rankIndex = 1;
      regenerateResult.poules.forEach(poule => {
        poule.players.forEach(player => {
          const nameParts = (player.name || '').trim().split(' ');
          const firstName = nameParts[0] || '';
          const lastName = nameParts.slice(1).join(' ') || '';
          const cleanLicence = player.licence?.replace(/\s/g, '');
          const email = playerEmails[cleanLicence] || '';

          selectedPlayers.push({
            licence: player.licence,
            first_name: firstName,
            last_name: lastName,
            name: player.name,
            club: player.club,
            rank: player.rank,
            finalRank: rankIndex++,
            isNouveau: player.isNouveau,
            isNew: player.isNouveau,
            email: email
          });
        });
      });

      // Fill summary elements
      document.getElementById('summaryCategory').textContent = currentCategory.display_name;
      const isFinale = t.nom?.toLowerCase().includes('finale') || currentTournament === '4';
      document.getElementById('summaryTournament').textContent = isFinale ? 'Finale D√©partementale' : `Tournoi ${currentTournament}`;
      window.currentCompetitionIsFinale = isFinale;

      const dateStr = t.debut
        ? new Date(t.debut).toLocaleDateString('fr-FR', { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric' })
        : 'Non d√©finie';
      document.getElementById('summaryDate').textContent = dateStr;
      document.getElementById('summaryLieu').textContent = t.lieu || 'Non d√©fini';
      document.getElementById('summaryPlayers').textContent = regenerateResult.playerCount;

      // Calculate config description
      const pouleDesc = regenerateResult.poules.map(p => `${p.players.length}`).join(', ');
      document.getElementById('summaryConfig').textContent = `${regenerateResult.pouleCount} poules (${pouleDesc} joueurs)`;
      document.getElementById('summaryTables').textContent = regenerateResult.pouleCount;

      // Convert poules format for renderPoulePreview
      // renderPoulePreview expects first_name and last_name separately
      const poulesForPreview = regenerateResult.poules.map(p => ({
        number: p.number,
        size: p.players.length,
        players: p.players.map((player, idx) => {
          // Split name into first_name and last_name (name format: "FirstName LastName")
          const nameParts = (player.name || '').trim().split(' ');
          const firstName = nameParts[0] || '';
          const lastName = nameParts.slice(1).join(' ') || '';
          return {
            licence: player.licence,
            first_name: firstName,
            last_name: lastName,
            club: player.club,
            finalRank: player.rank || idx + 1,
            pouleRank: idx + 1,
            isNew: player.isNouveau
          };
        })
      }));

      // Render poule preview
      document.getElementById('poulePreviewTitle').innerHTML = 'Aper√ßu des Poules (Distribution Serpentine)';
      renderPoulePreview(poulesForPreview);

      // Pre-select location if available
      if (t.lieu) {
        preselectLocation(t.lieu);
      }

      // Reset second location
      document.getElementById('location2Container').style.display = 'none';
      document.getElementById('addLocation2Btn').style.display = 'inline-block';
      document.getElementById('locationSelect2').value = '';

      // Load game parameters
      loadGameParameters();

      // Show step indicators and navigate to step 3
      document.getElementById('stepIndicatorContainer').style.display = 'flex';
      goToStep(3);
    }

    // Resend convocations - navigate to the existing email screen with data pre-loaded
    async function resendConvocationsFromForfait() {
      if (!forfaitSelectedTournoi || !forfaitCurrentPoules || forfaitCurrentPoules.length === 0) {
        alert('Aucune poule disponible');
        return;
      }

      const btn = document.getElementById('resendConvocationsBtn');
      btn.disabled = true;
      btn.textContent = 'Chargement...';

      try {
        // Fetch tournament details
        const tournoiResponse = await fetch(`${API_URL}/email/poules/${forfaitSelectedTournoi}`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        if (!tournoiResponse.ok) throw new Error('Impossible de charger les d√©tails du tournoi');
        const tournoiData = await tournoiResponse.json();
        const t = tournoiData.tournament;

        // Get all active players from current poules
        const allPlayers = [];
        forfaitCurrentPoules.forEach(poule => {
          poule.players.forEach(player => {
            if (!player.isForfait) {
              allPlayers.push({
                licence: player.licence,
                name: player.player_name,
                first_name: player.player_name?.split(' ').slice(1).join(' ') || '',
                last_name: player.player_name?.split(' ')[0] || player.player_name,
                club: player.club
              });
            }
          });
        });

        if (allPlayers.length === 0) {
          alert('Aucun joueur actif dans les poules');
          btn.disabled = false;
          btn.textContent = '‚úâÔ∏è Renvoyer les convocations';
          return;
        }

        // Fetch inscriptions to get emails
        const inscResponse = await fetch(`${API_URL}/inscriptions?tournoi_id=${forfaitSelectedTournoi}`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        if (inscResponse.ok) {
          const inscData = await inscResponse.json();
          // Populate playerEmails global object (used by updateEmailStats)
          // API returns array directly, not {inscriptions: [...]}
          playerEmails = {};
          const inscriptions = Array.isArray(inscData) ? inscData : (inscData.inscriptions || []);
          console.log('Inscriptions loaded:', inscriptions.length, 'entries');
          inscriptions.forEach(insc => {
            console.log('Inscription:', insc.licence, 'email:', insc.email);
            const cleanLicence = insc.licence?.replace(/\s/g, '');
            if (cleanLicence && insc.email) {
              playerEmails[cleanLicence] = insc.email;
            }
            // Also set on player object
            const player = allPlayers.find(p => p.licence?.replace(/\s/g, '') === cleanLicence);
            if (player && insc.email) {
              player.email = insc.email;
            }
          });
        }

        // Build locations data as array (email API expects array with locationNum, name, street, startTime)
        // Build this first so we can assign locationNum to each poule
        const locationsMap = new Map();
        forfaitCurrentPoules.forEach(poule => {
          const locKey = poule.location_name || 'Location 1';
          if (!locationsMap.has(locKey)) {
            locationsMap.set(locKey, {
              locationNum: String(locationsMap.size + 1),
              name: poule.location_name || '',
              street: poule.location_address || '',
              city: '',
              zip_code: '',
              startTime: poule.start_time || '14:00'
            });
          }
        });
        const locations = Array.from(locationsMap.values());
        console.log('Locations for email:', locations);

        // Build poules data with locationNum for email API
        // Helper to split player name (format: "LASTNAME FIRSTNAME" or "LASTNAME (Nickname) FIRSTNAME")
        const splitPlayerName = (fullName) => {
          if (!fullName) return { first_name: '', last_name: '' };
          const parts = fullName.trim().split(/\s+/);
          if (parts.length === 1) return { first_name: '', last_name: parts[0] };
          // First part is last name, rest is first name
          return {
            last_name: parts[0],
            first_name: parts.slice(1).join(' ')
          };
        };

        const poulesForApi = forfaitCurrentPoules.map(poule => {
          const locKey = poule.location_name || 'Location 1';
          const loc = locationsMap.get(locKey);
          return {
            number: poule.number,
            locationNum: loc?.locationNum || '1',
            players: poule.players.filter(p => !p.isForfait).map(p => {
              const nameParts = splitPlayerName(p.player_name);
              return {
                licence: p.licence,
                name: p.player_name,
                first_name: nameParts.first_name,
                last_name: nameParts.last_name,
                club: p.club
              };
            })
          };
        });
        console.log('Poules for email:', poulesForApi);

        // Set global variables used by the email section
        selectedPlayers = allPlayers;

        // Find matching category from categories array (required by email API for ranking data)
        // Normalize for comparison and expand abbreviations
        const normalizeForMatch = (str) => (str || '').toUpperCase().replace(/\s+/g, ' ').trim();

        // Expand category abbreviations (R1 ‚Üí REGIONALE 1, N3 ‚Üí NATIONALE 3, etc.)
        const expandAbbreviation = (abbrev) => {
          const upper = (abbrev || '').toUpperCase().trim();
          const expansions = {
            'R1': 'REGIONALE 1', 'R2': 'REGIONALE 2', 'R3': 'REGIONALE 3', 'R4': 'REGIONALE 4',
            'N1': 'NATIONALE 1', 'N2': 'NATIONALE 2', 'N3': 'NATIONALE 3', 'N4': 'NATIONALE 4',
            'D1': 'DEPARTEMENTALE 1', 'D2': 'DEPARTEMENTALE 2', 'D3': 'DEPARTEMENTALE 3'
          };
          return expansions[upper] || upper;
        };

        const tournoiMode = normalizeForMatch(t.mode);
        const tournoiCategorie = normalizeForMatch(t.categorie);
        const tournoiCategorieExpanded = expandAbbreviation(tournoiCategorie);

        console.log('Looking for category:', tournoiMode, tournoiCategorie, '‚Üí expanded:', tournoiCategorieExpanded);
        console.log('Available categories:', categories.map(c => ({ id: c.id, name: c.display_name })));

        const matchingCategory = categories.find(c => {
          const catDisplay = normalizeForMatch(c.display_name);
          // Try with expanded abbreviation (e.g., "3 BANDES R2" ‚Üí matches "3 BANDES - REGIONALE 2")
          if (catDisplay.includes(tournoiMode) && catDisplay.includes(tournoiCategorieExpanded)) return true;
          // Try exact match
          if (catDisplay === `${tournoiMode} ${tournoiCategorie}`) return true;
          if (catDisplay === `${tournoiMode} - ${tournoiCategorie}`) return true;
          if (catDisplay === `${tournoiMode} - ${tournoiCategorieExpanded}`) return true;
          // Try with mode variations (e.g., "3 BANDES" matches "3BANDES")
          const modeNoSpace = tournoiMode.replace(/\s/g, '');
          if (catDisplay.replace(/\s/g, '').includes(modeNoSpace) && catDisplay.includes(tournoiCategorieExpanded)) return true;
          return false;
        });

        // Use matching category or create a fallback object with required fields
        currentCategory = matchingCategory || {
          id: null,
          display_name: `${t.mode} ${t.categorie}`,
          short_name: t.categorie
        };
        console.log('Matched category for email:', currentCategory);

        currentTournament = t.nom;

        // Set season based on tournament date
        const tournamentDate = new Date(t.debut);
        const year = tournamentDate.getFullYear();
        const month = tournamentDate.getMonth();
        // Season starts in September
        currentSeason = month >= 8 ? `${year}-${year + 1}` : `${year - 1}-${year}`;
        console.log('Season for email:', currentSeason);

        // Store generation data for the email section
        // skipClubReminders: true because this is a resend after forfait, club was already notified
        lastGeneratedData = {
          poules: poulesForApi,
          tournamentDate: t.debut,
          tournoiId: forfaitSelectedTournoi,
          locations: locations,
          gameParams: null,
          selectedDistance: null,
          skipClubReminders: true
        };

        // Close forfait modal
        closeForfaitModal();

        // Pre-fill the special note field
        document.getElementById('specialNoteField').value = 'Suite √† un d√©sistement, √©dition de cette nouvelle convocation.';

        // Update email stats and show email section
        updateEmailStats();

        // Navigate to step 4 (email section)
        goToStep(4);

        // Select all checkboxes by default (after a short delay to ensure DOM is ready)
        setTimeout(() => {
          document.getElementById('emailSelectAllBtn').click();
          document.getElementById('emailSection').scrollIntoView({ behavior: 'smooth' });
        }, 100);

      } catch (error) {
        console.error('Error loading resend data:', error);
        alert('Erreur: ' + error.message);
      } finally {
        btn.disabled = false;
        btn.textContent = '‚úâÔ∏è Renvoyer les convocations';
      }
    }

    async function regeneratePoules(withReplacement = false) {
      // Allow regeneration even without selecting forfait (to reintegrate reinstated players)

      // If we have preview data, just confirm it
      if (forfaitPreviewData) {
        await confirmRegeneration();
        return;
      }

      // Otherwise show preview first
      await previewPoules();
    }

    // Replacement player modal
    function openReplacementModal() {
      if (forfaitSelectedPlayers.size === 0) {
        alert('Veuillez d\'abord s√©lectionner au moins un joueur forfait');
        return;
      }
      document.getElementById('replacementModal').style.display = 'flex';
      document.getElementById('replacementSearch').value = '';
      document.getElementById('replacementResults').innerHTML = '<div style="padding: 20px; text-align: center; color: #666;">Tapez pour rechercher...</div>';
      document.getElementById('confirmReplacementBtn').disabled = true;
      forfaitReplacementPlayer = null;
    }

    function closeReplacementModal() {
      document.getElementById('replacementModal').style.display = 'none';
    }

    let replacementSearchTimeout = null;
    function handleReplacementSearch(e) {
      clearTimeout(replacementSearchTimeout);
      const query = e.target.value.trim();

      if (query.length < 2) {
        document.getElementById('replacementResults').innerHTML = '<div style="padding: 20px; text-align: center; color: #666;">Tapez au moins 2 caract√®res...</div>';
        return;
      }

      document.getElementById('replacementResults').innerHTML = '<div style="padding: 20px; text-align: center; color: #666;">Recherche...</div>';

      replacementSearchTimeout = setTimeout(async () => {
        try {
          const response = await fetch(`${API_URL}/rankings/search?q=${encodeURIComponent(query)}&limit=20`, {
            headers: { 'Authorization': `Bearer ${token}` }
          });

          if (!response.ok) throw new Error('Search failed');
          const players = await response.json();

          if (players.length === 0) {
            document.getElementById('replacementResults').innerHTML = '<div style="padding: 20px; text-align: center; color: #666;">Aucun joueur trouv√©</div>';
            return;
          }

          // Filter out players already in poules
          const existingLicences = new Set();
          forfaitCurrentPoules.forEach(p => {
            p.players.forEach(pl => existingLicences.add(pl.licence?.replace(/\s/g, '')));
          });

          document.getElementById('replacementResults').innerHTML = players.map(player => {
            const isInPoules = existingLicences.has(player.licence?.replace(/\s/g, ''));
            return `
              <div class="replacement-option ${isInPoules ? 'disabled' : ''}"
                   onclick="${isInPoules ? '' : `selectReplacementPlayer('${player.licence}', '${player.first_name} ${player.last_name}', '${player.club || ''}')`}"
                   style="padding: 10px 15px; border-bottom: 1px solid #eee; cursor: ${isInPoules ? 'not-allowed' : 'pointer'};
                          background: ${isInPoules ? '#f8f9fa' : 'white'}; opacity: ${isInPoules ? '0.5' : '1'};">
                <div style="font-weight: 500;">${player.first_name} ${player.last_name}</div>
                <div style="font-size: 12px; color: #666;">${player.club || ''} - ${player.licence}</div>
                ${isInPoules ? '<div style="font-size: 11px; color: #dc3545;">D√©j√† dans les poules</div>' : ''}
              </div>
            `;
          }).join('');

        } catch (error) {
          console.error('Search error:', error);
          document.getElementById('replacementResults').innerHTML = '<div style="padding: 20px; text-align: center; color: #dc3545;">Erreur de recherche</div>';
        }
      }, 300);
    }

    function selectReplacementPlayer(licence, name, club) {
      forfaitReplacementPlayer = { licence, name, club };
      document.getElementById('confirmReplacementBtn').disabled = false;

      // Highlight selected
      document.querySelectorAll('.replacement-option').forEach(el => {
        el.style.background = 'white';
      });
      event.currentTarget.style.background = '#d4edda';
    }

    async function confirmReplacement() {
      if (!forfaitReplacementPlayer) {
        alert('Veuillez s√©lectionner un joueur rempla√ßant');
        return;
      }
      closeReplacementModal();
      await regeneratePoules(true);
    }
  </script>

  <!-- Forfait Management Modal -->
  <div id="forfaitModal" class="modal" style="display: none;">
    <div class="modal-content" style="max-width: 1000px; max-height: 90vh; overflow-y: auto;">
      <div class="modal-header" style="background: linear-gradient(135deg, #dc3545 0%, #a71d2a 100%); color: white; padding: 20px; border-radius: 8px 8px 0 0;">
        <h3 style="margin: 0; font-size: 18px;">üö´ Gestion des forfaits</h3>
        <span class="close-modal" onclick="closeForfaitModal()">&times;</span>
      </div>
      <div style="padding: 20px;">
        <!-- Selectors -->
        <div style="display: flex; gap: 15px; margin-bottom: 20px; flex-wrap: wrap;">
          <div style="flex: 1; min-width: 200px;">
            <label style="display: block; font-size: 12px; color: #666; margin-bottom: 4px;">Cat√©gorie</label>
            <select id="forfaitCategorySelect" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px;">
              <option value="">Chargement...</option>
            </select>
          </div>
          <div style="flex: 1; min-width: 200px;">
            <label style="display: block; font-size: 12px; color: #666; margin-bottom: 4px;">Comp√©tition</label>
            <select id="forfaitCompetitionSelect" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px;">
              <option value="">S√©lectionnez une cat√©gorie</option>
            </select>
          </div>
        </div>

        <!-- Tournament Info -->
        <div id="forfaitTournamentInfo" style="display: none; background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
          <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;">
            <div>
              <strong id="forfaitTournamentName" style="font-size: 16px;"></strong>
              <div style="color: #666; font-size: 13px;">
                <span id="forfaitTournamentDate"></span> - <span id="forfaitTournamentLieu"></span>
              </div>
            </div>
            <div id="forfaitPlayerCount" style="font-size: 14px; color: #1F4788;"></div>
          </div>
        </div>

        <!-- Instructions -->
        <div id="forfaitInstructions" style="background: #e7f3ff; padding: 12px 15px; border-radius: 6px; margin-bottom: 20px; font-size: 13px; color: #0c5460;">
          <strong>üí° Instructions :</strong> Cliquez sur un joueur pour le d√©clarer forfait. Vous pourrez ensuite r√©g√©n√©rer les poules.
        </div>

        <!-- Current Poules Display -->
        <div id="forfaitPoulesContainer" style="display: none;">
          <h4 style="margin: 0 0 15px 0; color: #333;">Composition actuelle des poules</h4>
          <div id="forfaitPoulesList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 15px;">
            <!-- Poules will be loaded here -->
          </div>
        </div>

        <!-- Forfait Players Section -->
        <div id="forfaitPlayersSection" style="display: none; margin-top: 20px; padding: 15px; background: #fff3cd; border-radius: 8px; border: 1px solid #ffc107;">
          <h4 style="margin: 0 0 15px 0; color: #856404; display: flex; align-items: center; gap: 8px;">
            <span>üë§</span> Joueurs forfait (<span id="forfaitPlayersCount">0</span>)
          </h4>
          <p style="font-size: 12px; color: #856404; margin: 0 0 15px 0;">
            Ces joueurs sont marqu√©s forfait. Cliquez sur "R√©int√©grer" pour les remettre dans la liste des inscrits.
          </p>
          <div id="forfaitPlayersList" style="display: flex; flex-direction: column; gap: 8px;">
            <!-- Forfait players will be loaded here -->
          </div>
        </div>

        <!-- No Poules Message -->
        <div id="forfaitNoPoules" style="display: none; text-align: center; padding: 40px; color: #666;">
          <div style="font-size: 48px; margin-bottom: 15px;">üìã</div>
          <p>Aucune poule enregistr√©e pour cette comp√©tition.</p>
          <p style="font-size: 13px;">Les poules sont enregistr√©es lors de l'envoi des convocations.</p>
        </div>

        <!-- Action Buttons -->
        <div id="forfaitActions" style="display: none; margin-top: 20px; padding-top: 20px; border-top: 1px solid #eee;">
          <div style="display: flex; gap: 10px; flex-wrap: wrap;">
            <button id="regeneratePoulesBtn" class="btn" style="background: #28a745; color: white;" onclick="previewPoules()">
              üîÑ R√©g√©n√©rer les poules
            </button>
            <button id="regenerateWithReplacementBtn" class="btn" style="background: #1F4788; color: white;" onclick="openReplacementModal()">
              üë§ Ajouter un rempla√ßant
            </button>
          </div>
          <div id="forfaitSummary" style="margin-top: 15px; padding: 10px; background: #fff3cd; border-radius: 6px; display: none;">
            <strong>Forfaits s√©lectionn√©s :</strong> <span id="forfaitList"></span>
          </div>
        </div>

        <!-- Preview Result (separate from actions so it can replace poules view) -->
        <div id="forfaitPreview" style="display: none; padding: 15px; background: #e7f3ff; border: 2px solid #17a2b8; border-radius: 8px;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <h4 style="margin: 0; color: #0c5460;">üëÅÔ∏è Pr√©visualisation des nouvelles poules</h4>
          </div>
          <div id="forfaitPreviewPoules" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 10px;"></div>
          <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #17a2b8; display: flex; gap: 10px; justify-content: center;">
            <button class="btn" style="background: #28a745; color: white; padding: 12px 24px; font-size: 15px;" onclick="confirmRegeneration()">‚úì Confirmer et enregistrer</button>
            <button class="btn" style="background: #dc3545; color: white; padding: 12px 24px; font-size: 15px;" onclick="closePreview()">‚úï Annuler</button>
          </div>
        </div>

        <!-- Loading -->
        <div id="forfaitLoading" style="display: none; text-align: center; padding: 40px;">
          <div style="font-size: 24px; margin-bottom: 10px;">‚è≥</div>
          <p>Chargement...</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Replacement Player Modal -->
  <div id="replacementModal" class="modal" style="display: none;">
    <div class="modal-content" style="max-width: 500px;">
      <div class="modal-header" style="background: linear-gradient(135deg, #1F4788 0%, #163560 100%); color: white; padding: 20px; border-radius: 8px 8px 0 0;">
        <h3 style="margin: 0; font-size: 18px;">üë§ Ajouter un rempla√ßant</h3>
        <span class="close-modal" onclick="closeReplacementModal()">&times;</span>
      </div>
      <div style="padding: 20px;">
        <p style="margin: 0 0 15px 0; color: #666; font-size: 13px;">
          Recherchez et s√©lectionnez un joueur pour remplacer le forfait.
        </p>
        <input type="text" id="replacementSearch" placeholder="Rechercher un joueur (nom ou licence)..."
          style="width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px; margin-bottom: 15px;">
        <div id="replacementResults" style="max-height: 300px; overflow-y: auto; border: 1px solid #eee; border-radius: 6px;">
          <div style="padding: 20px; text-align: center; color: #666;">Tapez pour rechercher...</div>
        </div>
        <div style="margin-top: 15px; display: flex; gap: 10px;">
          <button class="btn" style="background: #6c757d;" onclick="closeReplacementModal()">Annuler</button>
          <button id="confirmReplacementBtn" class="btn" style="background: #28a745; color: white;" onclick="confirmReplacement()" disabled>
            Confirmer et r√©g√©n√©rer
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Simulation Modal -->
  <div id="simulationModal" class="modal" style="display: none;">
    <div class="modal-content" style="max-width: 900px; max-height: 90vh; overflow-y: auto;">
      <div class="modal-header" style="background: linear-gradient(135deg, #1F4788 0%, #163560 100%); color: white; padding: 20px; border-radius: 8px 8px 0 0;">
        <h3 id="simulationTitle" style="margin: 0; font-size: 18px;">Simulation des poules</h3>
        <span class="close-modal" onclick="closeSimulationModal()">&times;</span>
      </div>
      <div style="background: #fff3cd; padding: 12px 20px; border-bottom: 1px solid #ffc107;">
        <p style="margin: 0; font-size: 13px; color: #856404;">
          ‚ö†Ô∏è <strong>SIMULATION</strong> - Cette r√©partition est indicative et peut diff√©rer de la convocation officielle.
        </p>
      </div>
      <div id="simulationContent" style="padding: 20px;">
        <!-- Content will be loaded here -->
      </div>
    </div>
  </div>
</body>
</html>
